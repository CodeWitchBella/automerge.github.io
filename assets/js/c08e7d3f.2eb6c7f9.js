"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3285],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=l(n),h=a,p=m["".concat(c,".").concat(h)]||m[h]||d[h]||r;return n?o.createElement(p,i(i({ref:t},u),{},{components:n})):o.createElement(p,i({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2481:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return m}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],s={sidebar_position:1},c="Modeling Data",l={unversionedId:"cookbook/modeling-data",id:"cookbook/modeling-data",isDocsHomePage:!1,title:"Modeling Data",description:"All data in Automerge must be stored in a document. A document can be modeled in a variety of ways, and there are many design patterns that can be used. An application could have many documents, typically identified by a UUID.",source:"@site/docs/cookbook/modeling-data.md",sourceDirName:"cookbook",slug:"/cookbook/modeling-data",permalink:"/docs/docs/cookbook/modeling-data",editUrl:"https://github.com/automerge/docs/edit/main/docs/cookbook/modeling-data.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Table",permalink:"/docs/docs/types/table"},next:{title:"Real-time Collaboration",permalink:"/docs/docs/cookbook/real-time"}},u=[{value:"How many documents?",id:"how-many-documents",children:[],level:2},{value:"TypeScript support",id:"typescript-support",children:[],level:2},{value:"Merging two disjointed documents",id:"merging-two-disjointed-documents",children:[],level:2},{value:"Versioning",id:"versioning",children:[],level:2},{value:"Performance",id:"performance",children:[],level:2}],d={toc:u};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"modeling-data"},"Modeling Data"),(0,r.kt)("p",null,"All data in Automerge must be stored in a document. A document can be modeled in a variety of ways, and there are many design patterns that can be used. An application could have many documents, typically identified by a UUID. "),(0,r.kt)("p",null,"In this section, we will discuss how to model data within a particular document, including how to version and manage data with Automerge in production scenarios."),(0,r.kt)("h2",{id:"how-many-documents"},"How many documents?"),(0,r.kt)("p",null,"You can decide which things to group together as one Automerge document (more fine grained or more coarse grained) based on what makes sense in your app. Having hundreds of docs should be fine \u2014 we've built prototypes of that scale. One major automerge project, ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/automerge/pushpin"},"PushPin"),", was built around very granular documents. This had a lot of benefits, but the overhead of syncing many thousands of documents was high. One of the first challenges in synchronizing large numbers of documents is that nodes are likely to have overlapping but disjoint documents and neither side wants to disclose things the other doesn't know about (at least in our last system, knowing the ID of a document was evidence a client should have access to it.)  "),(0,r.kt)("p",null,"We believe on the whole there's an art to the granularity of data that is universal. When should you have two JSON documents or two SQLite databases or two rows? We suspect that an Automerge document is best suited to being a unit of collaboration between two people or a small group. For more about how these UUIDs can be used intelligently for authentication and document access as a unit of collaboration, see ",(0,r.kt)("a",{parentName:"p",href:"authentication"},"Authentication"),"."),(0,r.kt)("h2",{id:"typescript-support"},"TypeScript support"),(0,r.kt)("p",null,"Given that you have a document, how can you create safety rails for it's data integrity? In a typical SQL database, a table would have it's own schema, and you create one-way migrations for application versions. Automerge is flexible on the schema, and will let you add and remove properties and values at will. To improve the programming experience, a Document can be typed to have it's own schema using TypeScript."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"type D = { \n  count: Automerge.Counter,\n  text: Automerge.Text,\n  cards: [] \n}\nlet doc = Automerge.change<D>(Automerge.init(), (doc: D) => {\n  doc.count = new Automerge.Counter()\n  doc.text = new Automerge.Text()\n  doc.cards = []\n})\n")),(0,r.kt)("h2",{id:"merging-two-disjointed-documents"},"Merging two disjointed documents"),(0,r.kt)("p",null,"Few applications have multiple documents that need to be merged together at will. For example, in a Kanban-style app, if you wanted to merge two boards into one board, you can't do that unless the boards come from a common ancestor. To enable this use case, you can create a root change that two documents share. "),(0,r.kt)("p",null,"To create an initial root change for your Automerge document, you can make a change that has the same hash every time it is created. We do this by setting the actorId to a static string ",(0,r.kt)("inlineCode",{parentName:"p"},"'0000'")," and setting the time to always be 0."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let doc = Automerge.init('0000', {time: 0})\n")),(0,r.kt)("p",null,"We then modify this document to create the initial values for all of the types in the document."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"type D = { \n  count: Automerge.Counter,\n  text: Automerge.Text,\n  cards: [] \n}\nlet schema = Automerge.change<D>(Automerge.init('0000', {time: 0}), (doc: D) => {\n  doc.count = new Automerge.Counter()\n  doc.text = new Automerge.Text()\n  doc.cards = []\n})\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: You only have to create this initial change the first time the document loads. You can check if you have a local document already before making this initial document.")),(0,r.kt)("p",null,"Great, now we have an initial document that represents the base schema of our data model. But because we initialized this Automerge document with a fixed actorId, we need to create a new document that has a random id. We don't want all of our resulting changes to be with the actorId ",(0,r.kt)("inlineCode",{parentName:"p"},"0000"),", because that should be reserved for the initial change only."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let change = Automerge.getLastLocalChange(schema)\nconst [ doc , ]= Automerge.applyChanges(Automerge.init<D>(), [change])\n")),(0,r.kt)("p",null,"The full resulting code is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function createFrozenAncestor()  {\n  let schema = Automerge.change<D>(Automerge.init('0000', {time: 0}), (doc: D) => {\n    doc.count = new Automerge.Counter()\n    doc.text = new Automerge.Text()\n    doc.cards = []\n  })\n  let change = Automerge.getLastLocalChange(schema)\n  const [ doc , ]= Automerge.applyChanges(Automerge.init<D>(), [change])\n  return doc\n}\n")),(0,r.kt)("p",null,"Now, ",(0,r.kt)("inlineCode",{parentName:"p"},"doc")," is initialized and ready to be used as any other Automerge document. You can save that document to disk as you would normally with ",(0,r.kt)("inlineCode",{parentName:"p"},"Automerge.save(doc)")," and load it later when your app starts."),(0,r.kt)("h2",{id:"versioning"},"Versioning"),(0,r.kt)("p",null,"Often, there comes a time in the production lifecycle where you will need to change the schema of a document. Because Automerge uses a JSON document model, it's similar to a NoSQL database, where properties can be arbitrarily removed and added at will. "),(0,r.kt)("p",null,"However, we strongly recommend versioning your documents. This allows you to detect older document versions and modify, upgrade, or migrate those documents on the fly. This also provides some enforcement of schema versions. All merged documents will have to be children of the initial document. If the initial document schema changes, you will need to migrate the older document to the new document. "),(0,r.kt)("p",null,"For example, if you change the ",(0,r.kt)("inlineCode",{parentName:"p"},"cards")," property in the above example to an ",(0,r.kt)("inlineCode",{parentName:"p"},"Automerge.Table"),", users who upgrade to the latest version of the application may see unexpected behavior. Below is an example of adding versions to your documents. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"type D = { \n  version: 1,\n  count: Automerge.Counter,\n  text: Automerge.Text,\n  cards: []\n}\n\ntype E = { \n  version: 2,\n  count: Automerge.Counter,\n  text: Automerge.Text,\n  cards: Automerge.Table\n}\n\nlet doc1 = getDocumentFromNetwork()\nlet doc2 = localDocument()\n\nif (doc1.version === 1) {\n  doc1 = migrate(doc1)\n}\n")),(0,r.kt)("p",null,"This is heavily dependent upon your user experience requirements and your data model. In some cases, you may want to enforce that users are on the most up-to-date version of the application. In other cases, it is important that the application never prevents the user from editing the database on the local machine, even in the case where the application is out of date. However, this is overall an understudied area of CRDTs that needs more work -- hopefully from you! Ink & Switch wrote about this topic in the ",(0,r.kt)("a",{parentName:"p",href:"https://www.inkandswitch.com/cambria"},"Cambria")," paper, and there is still much left to do to make nicer primitives for developers to use, rather than handcrafting each migration."),(0,r.kt)("h2",{id:"performance"},"Performance"),(0,r.kt)("p",null,"Automerge documents hold their entire change histories. It is fairly performant, and can handle a significant amount of data in a single document's history.  Performance depends very much on your workload, so we strongly suggest you do your own measurements with the type and quantity of data that you will have in your app. "),(0,r.kt)("p",null,"Some developers have proposed \u201cgarbage collecting\u201d large documents. If a document gets to a certain size, a central authority could emit a message to each peer that it would like to reduce it in size and only save the history from a specific change (hash). Martin Kleppman did some experiments with a benchmark document to see how much space would be saved by discarding history, with and without preserving tombstones. See ",(0,r.kt)("a",{parentName:"p",href:"https://youtu.be/x7drE24geUw?t=3289"},"this video at 55 minutes in"),". The savings are not all that great, which is why we haven't prioritised history truncation so far. "),(0,r.kt)("p",null,"Typically, performance improvements can come at the networking level. You can set up a single connection (between peers or client-server) and sync many docs over a single connection. The basic idea is to tag each message with the ID of the document it belongs to. There are possible ways of optimising this if necessary. In general, having fewer documents that a client must load over the network or into memory at any given time will reduce the syncronization and startup time for your application."))}m.isMDXComponent=!0}}]);