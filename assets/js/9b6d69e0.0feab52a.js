"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9792],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>p});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=l(n),p=o,m=u["".concat(c,".").concat(p)]||u[p]||d[p]||r;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2607:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const r={},i="How Automerge works",s={unversionedId:"how-it-works/backend",id:"how-it-works/backend",isDocsHomePage:!1,title:"How Automerge works",description:"This document explains how Automerge stores data internally. You shouldn't need",source:"@site/docs/how-it-works/backend.md",sourceDirName:"how-it-works",slug:"/how-it-works/backend",permalink:"/docs/how-it-works/backend",editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/how-it-works/backend.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Managing Conflicts",permalink:"/docs/cookbook/conflicts"},next:{title:"Binary Document Format",permalink:"/docs/how-it-works/binary-format"}},c=[{value:"Document, changes, and operations",id:"document-changes-and-operations",children:[],level:2},{value:"Actor IDs and dependencies",id:"actor-ids-and-dependencies",children:[],level:2}],l={toc:c};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-automerge-works"},"How Automerge works"),(0,o.kt)("p",null,"This document explains how Automerge stores data internally. You shouldn't need\nto read it in order to use Automerge in your application, but you might find it\nuseful if you want to hack on the Automerge code itself."),(0,o.kt)("h2",{id:"document-changes-and-operations"},"Document, changes, and operations"),(0,o.kt)("p",null,"You get an Automerge instance by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.init()")," (creates a new, empty\ndocument) or ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.load()")," (loads an existing document, typically from\na file on disk). By default, this document exists only in memory on a single\ndevice, and you don't need any network communication for read or write access.\nThere may be a separate networking layer that asynchronously propagates changes\nfrom one device to another, but that networking layer is outside of the scope of\nAutomerge itself."),(0,o.kt)("p",null,"The Automerge instance represents the current state of your application (or some part of it).\nThe state is immutable and is never updated in place. Instead, whenever you want\nto do something that changes the state, you call a function that takes the old\nstate as first argument, and returns a new state reflecting the change. There\nare two ways how the state can change:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Local changes"),", which are generally triggered by the user changing some\npiece of application data in the user interface. Such editing by the user is\nexpressed by calling ",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.change()"),", which groups together a block\nof operations that should be applied as an atomic unit. Within the change\ncallback you have access to a mutable version of the Automerge document,\nimplemented as a\n",(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"Proxy"),").\nThe proxy records any mutations you make as ",(0,o.kt)("em",{parentName:"li"},"operations")," (e.g. changing the\nvalue of a particular property of a particular object). The ",(0,o.kt)("inlineCode",{parentName:"li"},"change()"),"\nfunction returns a new copy of the state with those operations applied."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Remote changes"),": a user on another device has edited their copy of\na document, that change was sent to you via the network, and now you want\nto apply it to your own copy of the document. Remote operations are applied\nusing ",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.applyChanges()"),", which again returns a new copy of the\nstate. For testing purposes there is also ",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.merge()"),', which is\nis a short-cut for the case where the "remote" document is actually just\nanother instance of Automerge in the same process.')),(0,o.kt)("p",null,"Some terminology:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An ",(0,o.kt)("strong",{parentName:"li"},"operation")," is a fine-grained description of a single modification, e.g.\nsetting the value of a particular property of a particular object, or\ninserting one element into a list. Users normally never see operations \u2014 they\nare a low-level implementation detail."),(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("strong",{parentName:"li"},"change")," is a collection of operations grouped into a unit that is\napplied atomically (a bit like a database transaction). Each call to\n",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.change()")," produces exactly one change, and inside the change there\nmay be any number of operations. A change is also the smallest unit that gets\ntransmitted over the network to other devices."),(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("strong",{parentName:"li"},"document")," is the state of a single Automerge instance. The state of a\ndocument is determined by the set of all changes that have been applied to\nit. Automerge ensures that whenever any two documents have seen the same\nset of changes, even if the changes were applied in a different order, then\nthose documents are in the same state. This means an Automerge document is a\n",(0,o.kt)("a",{parentName:"li",href:"https://crdt.tech/"},"CRDT"),".")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.getChanges()")," returns all the changes that have occurred between one\ndocument state and another, so that they can be encoded and sent over the\nnetwork to other devices. On the recipient's end, ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.applyChanges()"),"\nupdates the corresponding document to incorporate those changes."),(0,o.kt)("p",null,"You can save a document to disk using ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.save()"),". This function returns\na byte array in which the state of the document has been encoded in a compressed\nform. Conversely, ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.load()")," decodes that byte array and returns an\ninstance of the document. You can store this byte array in whatever way works\nbest on your platform, e.g. as a file on the filesystem, or in IndexedDB in\na web browser. The saved document state actually contains the entire change\nhistory of the document (a bit like a Git repository), but the compression makes\nthis efficient."),(0,o.kt)("p",null,"One day, we may need to allow this history to be pruned in order to save disk\nspace. There are also privacy implications in storing the whole history: any\nnew collaborator who gets access to a document can see all past states of the\ndocument, including any content that is now deleted. However, for now we are\nchoosing to preserve all history as it makes synchronisation easier (imagine\na device that has been offline for a long time, and then needs to catch up on\neverything that has been changed by other users while it was offline).\nMoreover, being able to inspect edit history is itself a useful feature."),(0,o.kt)("h2",{id:"actor-ids-and-dependencies"},"Actor IDs and dependencies"),(0,o.kt)("p",null,"Each Automerge instance has an ",(0,o.kt)("strong",{parentName:"p"},"actor ID")," \u2014 a UUID that is generated randomly\nwhenever you do ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.init()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.load()")," (unless you explicitly\npass an actor ID into those functions). Whenever you make a local edit on that\nAutomerge instance, the operations are tagged with that actor ID as the origin.\nAll changes made on a Automerge instance are numbered sequentially, starting\nwith 1 and never skipping or reusing sequence numbers. We assume that nobody\nelse is using the same actor ID, and thus each change is uniquely identified\nby the combination of its originating actor ID and its sequence number. That\nunique identifier for the change always remains fixed, even when it is\napplied on remote copies of the document."),(0,o.kt)("p",null,"An actor ID is a bit similar to a device ID. Each device can generate changes\nindependently from every other device, and so each device needs to have its own\nnumbering sequence. You can have several actor IDs for the same device, for\nexample if the user might run several instances of the application on the same\ndevice (in which case, each instance needs its own actor ID). However, there is\na performance cost to having lots of actor IDs, so it's a good idea to keep\nusing the same actor ID if possible (at least for the lifetime of an application\nprocess)."),(0,o.kt)("p",null,"When you make several changes to a document over time, later changes may depend\non earlier ones. For example, an earlier change may create a list object, and\na later change may insert an item into that list. To track those changes, each\nchange contains the SHA-256 hashes of the changes it depends on (similarly to\nhow a Git commit contains the hashes of the previous commit)."),(0,o.kt)("p",null,"In a sequential editing history, each change contains has only one dependency\nhash. But if several users are working concurrently (perhaps even working\noffline), the hash graph may contain branches and merges. A merge occurs when\nthere is a change that has more than one dependency, similarly to a merge commit\nin Git. "),(0,o.kt)("p",null,"When we send changes from one device to another, we apply the changes in the\norder specified by the dependencies between them. ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.applyChanges()"),"\nperforms this ordering automatically. If two changes appear in parallel\nbranches, we call them ",(0,o.kt)("em",{parentName:"p"},"concurrent"),", and they may be applied in either order."))}h.isMDXComponent=!0}}]);