"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9792],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,u=c["".concat(l,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(u,r(r({ref:t},h),{},{components:n})):a.createElement(u,r({ref:t},h))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},2607:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return h},default:function(){return c}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],s={},l="How Automerge works",p={unversionedId:"how-it-works/backend",id:"how-it-works/backend",isDocsHomePage:!1,title:"How Automerge works",description:"This document explains how Automerge stores data internally. You shouldn't need",source:"@site/docs/how-it-works/backend.md",sourceDirName:"how-it-works",slug:"/how-it-works/backend",permalink:"/docs/how-it-works/backend",editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/how-it-works/backend.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Managing Conflicts",permalink:"/docs/cookbook/conflicts"},next:{title:"Binary Document Format",permalink:"/docs/how-it-works/binary-format"}},h=[{value:"Document, changes, and operations",id:"document-changes-and-operations",children:[],level:2},{value:"Actor IDs, vector clocks, and causality",id:"actor-ids-vector-clocks-and-causality",children:[{value:"Dependencies",id:"dependencies",children:[],level:3}],level:2},{value:"Change structure and operation types",id:"change-structure-and-operation-types",children:[],level:2},{value:"Frontend-backend protocol",id:"frontend-backend-protocol",children:[{value:"Change requests",id:"change-requests",children:[],level:3},{value:"Patch format",id:"patch-format",children:[],level:3}],level:2},{value:"Applying operations to the backend",id:"applying-operations-to-the-backend",children:[],level:2}],d={toc:h};function c(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-automerge-works"},"How Automerge works"),(0,o.kt)("p",null,"This document explains how Automerge stores data internally. You shouldn't need\nto read it in order to use Automerge in your application, but you might find it\nuseful if you want to hack on the Automerge code itself."),(0,o.kt)("h2",{id:"document-changes-and-operations"},"Document, changes, and operations"),(0,o.kt)("p",null,"You get an Automerge instance by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.init()")," (creates a new, empty\ndocument) or ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.load()")," (loads an existing document, typically from\na file on disk). By default, this document exists only in memory on a single\ndevice, and you don't need any network communication for read or write access.\nThere may be a separate networking layer that asynchronously propagates changes\nfrom one device to another, but that networking layer is outside of the scope of\nAutomerge itself."),(0,o.kt)("p",null,"The Automerge instance represents the current state of your application (or some part of it).\nThe state is immutable and is never updated in place. Instead, whenever you want\nto do something that changes the state, you call a function that takes the old\nstate as first argument, and returns a new state reflecting the change. There\nare two ways how the state can change:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Local changes"),", which are generally triggered by the user changing some\npiece of application data in the user interface. Such editing by the user is\nexpressed by calling ",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.change()"),", which groups together a block\nof operations that should be applied as an atomic unit. Within the change\ncallback you have access to a mutable version of the Automerge document,\nimplemented as a\n",(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"Proxy"),").\nThe proxy records any mutations you make as ",(0,o.kt)("em",{parentName:"li"},"operations")," (e.g. changing the\nvalue of a particular property of a particular object). The ",(0,o.kt)("inlineCode",{parentName:"li"},"change()"),"\nfunction returns a new copy of the state with those operations applied."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Remote changes"),": a user on another device has edited their copy of\na document, that change was sent to you via the network, and now you want\nto apply it to your own copy of the document. Remote operations are applied\nusing ",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.applyChanges()"),", which again returns a new copy of the\nstate. For testing purposes there is also ",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.merge()"),', which is\nis a short-cut for the case where the "remote" document is actually just\nanother instance of Automerge in the same process.')),(0,o.kt)("p",null,"Some terminology:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An ",(0,o.kt)("strong",{parentName:"li"},"operation")," is a fine-grained description of a single modification, e.g.\nsetting the value of a particular property of a particular object, or\ninserting one element into a list. Users normally never see operations \u2014 they\nare a low-level implementation detail."),(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("strong",{parentName:"li"},"change")," is a collection of operations grouped into a unit that is\napplied atomically (a bit like a database transaction). Each call to\n",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.change()")," produces exactly one change, and inside the change there\nmay be any number of operations. A change is also the smallest unit that gets\ntransmitted over the network to other devices."),(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("strong",{parentName:"li"},"document")," is the state of a single Automerge instance. The state of a\ndocument is determined by the set of all changes that have been applied to\nit. Automerge ensures that whenever any two documents have seen the same\nset of changes, even if the changes were applied in a different order, then\nthose documents are in the same state. This means an Automerge document is a\n",(0,o.kt)("a",{parentName:"li",href:"https://crdt.tech/"},"CRDT"),".")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.getChanges()")," returns all the changes that have occurred between one\ndocument state and another, so that they can be encoded and sent over the\nnetwork to other devices. On the recipient's end, ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.applyChanges()"),"\nupdates the corresponding document to incorporate those changes."),(0,o.kt)("p",null,"You can save a document to disk using ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.save()"),". This function really\njust takes all the changes that have ever happened in the document, and encodes\nthem as a string. Conversely, ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.load()")," decodes that string and applies\nall of the changes to a new, blank document. This works because we can always\nreconstruct the document state from the set of changes. For this reason, a\ndocument preserves its entire editing history, even across saves and reloads\n(a bit like a Git repository)."),(0,o.kt)("p",null,"One day, we may need to allow this history to be pruned in order to save disk\nspace. There are also privacy implications in storing the whole history: any\nnew collaborator who gets access to a document can see all past states of the\ndocument, including any content that is now deleted. However, for now we are\nchoosing to preserve all history as it makes synchronisation easier (imagine\na device that has been offline for a long time, and then needs to catch up on\neverything that has been changed by other users while it was offline).\nMoreover, being able to inspect edit history is itself a useful feature."),(0,o.kt)("h2",{id:"actor-ids-vector-clocks-and-causality"},"Actor IDs, vector clocks, and causality"),(0,o.kt)("p",null,"Each Automerge instance has an ",(0,o.kt)("strong",{parentName:"p"},"actor ID")," \u2014 a UUID that is generated randomly\nwhenever you do ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.init()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.load()")," (unless you explicitly\npass an actor ID into those functions). Whenever you make a local edit on that\nAutomerge instance, the operations are tagged with that actor ID as the origin.\nAll changes made on a Automerge instance are numbered sequentially, starting\nwith 1 and never skipping or reusing sequence numbers. We assume that nobody\nelse is using the same actor ID, and thus each change is uniquely identified\nby the combination of its originating actor ID and its sequence number. That\nunique identifier for the change always remains fixed, even when it is\napplied on remote copies of the document."),(0,o.kt)("p",null,"An actor ID is a bit similar to a device ID. Each device can generate changes\nindependently from every other device, and so each device needs to have its own\nnumbering sequence. You can have several actor IDs for the same device, for\nexample if the user might run several instances of the application on the same\ndevice (in which case, each instance needs its own actor ID). However, there is\na performance cost to having lots of actor IDs, so it's a good idea to keep\nusing the same actor ID if possible (at least for the lifetime of an application\nprocess)."),(0,o.kt)("p",null,"With those sequence numbers in place, we can fairly efficiently keep track of\nall changes we've seen: for each actor ID, we apply the changes\noriginating on that instance in strictly incrementing order; and then we only\nneed to store the highest sequence number we've seen for each actor ID. This\nmapping from actor ID to highest sequence number is called a ",(0,o.kt)("em",{parentName:"p"},"vector clock"),"."),(0,o.kt)("p",null,"The vector clock is useful when two peers are communicating, and need to\nfigure out which changes they need to send to each other in order to get in\nsync. If the peers send each other their vector clocks, each peer can see the\nhighest sequence number for each actor that the other peer has seen; if it has\nany changes with higher sequence numbers, it sends those. See ",(0,o.kt)("inlineCode",{parentName:"p"},"src/connection.js"),"\nfor an implementation of such a protocol."),(0,o.kt)("h3",{id:"dependencies"},"Dependencies"),(0,o.kt)("p",null,"In our documents, one change sometimes depends on another. For example, if\nan item is first added and then removed, it doesn't make sense to try to apply\nthe removal if you haven't already seen the addition (since you'd be trying to\nremove something that doesn't yet exist). This requires ",(0,o.kt)("em",{parentName:"p"},"causal ordering")," of\nchanges, which we implement by each change declaring its ",(0,o.kt)("em",{parentName:"p"},"dependencies"),"."),(0,o.kt)("p",null,"Every change by actor ",(0,o.kt)("em",{parentName:"p"},"X")," with sequence number ",(0,o.kt)("em",{parentName:"p"},"n")," (with ",(0,o.kt)("em",{parentName:"p"},"n")," > 1) implicitly\ndepends on ",(0,o.kt)("em",{parentName:"p"},"X"),"'s change with sequence number ",(0,o.kt)("em",{parentName:"p"},"n")," \u2013 1. Moreover, assume that\nin between ",(0,o.kt)("em",{parentName:"p"},"X")," generating change number ",(0,o.kt)("em",{parentName:"p"},"n")," \u2013 1 and change number ",(0,o.kt)("em",{parentName:"p"},"n"),", ",(0,o.kt)("em",{parentName:"p"},"X"),"\nreceived a change from actor ",(0,o.kt)("em",{parentName:"p"},"Y")," with sequence number ",(0,o.kt)("em",{parentName:"p"},"m"),". In that case, ",(0,o.kt)("em",{parentName:"p"},"X"),"'s\nchange ",(0,o.kt)("em",{parentName:"p"},"n")," also declares an explicit dependency on ",(0,o.kt)("em",{parentName:"p"},"Y"),"'s change ",(0,o.kt)("em",{parentName:"p"},"m"),"."),(0,o.kt)("p",null,"When any Automerge instance wants to apply a change that depends on another\nchange, it ensures that the dependency is applied first. If it has not yet\nreceived the dependency, the dependent change is buffered until the prerequisite\nchange arrives. This ordering and buffering process happens automatically, which\nmeans that you can pass changes to ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.applyChanges()")," in any order, and\nAutomerge will take care of applying them in causal order."),(0,o.kt)("h2",{id:"change-structure-and-operation-types"},"Change structure and operation types"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"NB. This section describes the format used by the currently released version\nof Automerge (on the ",(0,o.kt)("inlineCode",{parentName:"strong"},"main")," branch). A new format is in development on the\n",(0,o.kt)("inlineCode",{parentName:"strong"},"performance")," branch).")),(0,o.kt)("p",null,"Every change is a JSON object with five properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"actor"),": The actor ID on which the change originated (a UUID)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"seq"),": The sequence number of the change, starting with 1 for a given actor\nID and proceeding as an incrementing sequence."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"deps"),": The change's dependencies, represented as an object where keys are\nactor IDs and values are the highest sequence number seen from that actor:\n",(0,o.kt)("inlineCode",{parentName:"li"},"{[actorId1]: seq1, [actorId2]: seq2, ...}"),". The implicit dependency on\nsequence number ",(0,o.kt)("inlineCode",{parentName:"li"},"seq \u2013 1")," by the same ",(0,o.kt)("inlineCode",{parentName:"li"},"actor")," need not be declared. Any\ndependency that is also a transitive dependency of another change need not\nbe declared either."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"message"),': An optional human-readable "commit message" that describes the\nchange in a meaningful way. It is not interpreted by Automerge, only\nstored for introspection, debugging, undo, and similar purposes.'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ops"),": An array of operations that are grouped into this change.")),(0,o.kt)("p",null,"Each operation acts on an object, which is identified by a UUID. There are four\ntypes of object: ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," (represented in the document as a JavaScript object),\n",(0,o.kt)("inlineCode",{parentName:"p"},"list")," (represented as a JavaScript array), ",(0,o.kt)("inlineCode",{parentName:"p"},"text")," (represented as an instance\nof ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.Text"),"), and ",(0,o.kt)("inlineCode",{parentName:"p"},"table")," (represented as an instance of\n",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.Table"),"). When processing operations, we mostly consider just ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," as object types, because ",(0,o.kt)("inlineCode",{parentName:"p"},"table")," behaves almost like ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),", and\n",(0,o.kt)("inlineCode",{parentName:"p"},"text")," behaves almost like ",(0,o.kt)("inlineCode",{parentName:"p"},"list"),". The root of an Automerge document has\na special UUID that consists only of zeroes, and its type is always ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.Counter")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Date")," objects are not types of object for\nAutomerge purposes, but rather datatypes of values (see documentation of the\n",(0,o.kt)("inlineCode",{parentName:"p"},"set")," operation)."),(0,o.kt)("p",null,"Each operation in the ",(0,o.kt)("inlineCode",{parentName:"p"},"ops")," array of a change is a JSON object. Automerge\ncurrently uses the following types of operation:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'makeMap', obj: objectId }")),(0,o.kt)("p",{parentName:"li"},"The user created a new empty map object, and that object will henceforth be\nidentified by the UUID ",(0,o.kt)("inlineCode",{parentName:"p"},"obj"),". The contents of the map, and its position within\nthe document, are defined by subsequent operations. For the root object, which\nhas a fixed UUID consisting of all zeros, a ",(0,o.kt)("inlineCode",{parentName:"p"},"makeMap")," operation is not\nrequired.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'makeList', obj: objectId }")),(0,o.kt)("p",{parentName:"li"},"The user created a new empty list object, and that list will henceforth be\nidentified by the UUID ",(0,o.kt)("inlineCode",{parentName:"p"},"obj"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'makeText', obj: objectId }")),(0,o.kt)("p",{parentName:"li"},"The user created a new empty text sequence, and that sequence will henceforth\nbe identified by the UUI ",(0,o.kt)("inlineCode",{parentName:"p"},"obj"),". (A text sequence provides better performance\nfor text editing compared with using a regular JavaScript array.)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'makeTable', obj: objectId }")),(0,o.kt)("p",{parentName:"li"},"The user created a new empty table, and that table will henceforth be\nidentified by the UUID ",(0,o.kt)("inlineCode",{parentName:"p"},"obj"),". The table does not enforce a schema; the columns\nthat exist in the table depend on the contents of each row. Rows are added in\nsubsequent operations.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'ins', obj: listId, key: elemId, elem: uint }")),(0,o.kt)("p",{parentName:"li"},"The user inserted a new item into a list or text object. ",(0,o.kt)("inlineCode",{parentName:"p"},"obj")," is the UUID of\nthe object being modified. ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," is the ID of an existing element after which\nthe new element should be inserted, or the string ",(0,o.kt)("inlineCode",{parentName:"p"},"'_head'")," if the new element\nshould be inserted at the beginning of the list. ",(0,o.kt)("inlineCode",{parentName:"p"},"elem")," is an integer that is\nstrictly greater than the ",(0,o.kt)("inlineCode",{parentName:"p"},"elem")," value of any other element in this list at\nthe time of insertion."),(0,o.kt)("p",{parentName:"li"},"The ID of the newly inserted list element is constructed by concatenating the\nactor ID on which the operation originated, a colon character ",(0,o.kt)("inlineCode",{parentName:"p"},"':'"),", and the\nelem value (as a decimal string). This ID is unique per list: although\ndifferent actors may generate insertions with the same elem value, the same\nactor never reuses elems. This element ID is then used by subsequent ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"link")," operations to assign a value to the list element, by ",(0,o.kt)("inlineCode",{parentName:"p"},"del")," operations\nto delete the list element, and by ",(0,o.kt)("inlineCode",{parentName:"p"},"ins")," operations to insert new list\nelements after this one."),(0,o.kt)("p",{parentName:"li"},"Note that the operation does not use list indexes, which are not safe under\nconcurrent use, but instead uses unique identifiers for list elements. Note\nalso that this operation does not specify what value should be inserted into\nthe list; it only creates a placeholder at a particular position. A subsequent\n",(0,o.kt)("inlineCode",{parentName:"p"},"set")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"link")," operation is used to assign the actual value."),(0,o.kt)("p",{parentName:"li"},"The elem value looks a bit similar to a sequence number in the vector clock,\nbut it is different due to the requirement that it must be greater than ",(0,o.kt)("em",{parentName:"p"},"any\nother")," elem in that list (regardless of originating actor). This fact is\nrequired to ensure the list elements are ordered correctly. Technically, this\nconstruction is known as a\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lamport_timestamps"},"Lamport timestamp"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'set', obj: objectId, key: key, value: value, datatype: datatype }")),(0,o.kt)("p",{parentName:"li"},"The user assigned a value to a key in a map, added a row to a table, or\nassigned a value to an index in a list. ",(0,o.kt)("inlineCode",{parentName:"p"},"obj")," is the UUID of the object being\nmodified. If the object is a map, ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," is the name of the field being\nassigned. If the object is a list or text, ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," is the unique ID\nof the list element to be updated, as created by a prior ",(0,o.kt)("inlineCode",{parentName:"p"},"ins")," operation.\n",(0,o.kt)("inlineCode",{parentName:"p"},"value")," is always a primitive value (string, number, boolean, or null); use a\n",(0,o.kt)("inlineCode",{parentName:"p"},"link")," operation for assigning objects."),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"datatype")," property is usually absent, in which case the property value\nis just the primitive ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," as given. If the value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"datatype")," property\nis ",(0,o.kt)("inlineCode",{parentName:"p"},"'counter'"),", the value must be an integer, and it is turned into an\n",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.Counter")," object in the document. If the ",(0,o.kt)("inlineCode",{parentName:"p"},"datatype")," property is\n",(0,o.kt)("inlineCode",{parentName:"p"},"'timestamp'"),", the value is interpreted as the number of milliseconds since\nthe 1970 Unix epoch, and turned into a JavaScript\n",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"},"Date"),"\nobject in the document.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'link', obj: objectId, key: key, value: objectId }")),(0,o.kt)("p",{parentName:"li"},"The user took a previously created object (created with ",(0,o.kt)("inlineCode",{parentName:"p"},"makeMap"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"makeList"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"makeText"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"makeTable"),"), and made it a nested object within another\nobject. Put another way, this operation creates a reference or pointer from\none object to another. Multiple references to the same element are not allowed.\nMoreover, reference cycles are not allowed; the code currently doesn't check\nfor them, so if you create a cycle, you'll get infinite loops."),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"obj")," is the UUID of the object being modified (i.e. the parent object in the\nnesting). If the object is a map, ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," is the name of the property in the\nparent object being updated. If the object is a table, ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," is the primary\nkey of the row (= the object ID of the row). If the object is a list or text,\n",(0,o.kt)("inlineCode",{parentName:"p"},"key")," is the ID of the list element, as created by a prior ",(0,o.kt)("inlineCode",{parentName:"p"},"ins")," operation.\n",(0,o.kt)("inlineCode",{parentName:"p"},"value")," is the UUID of the object being referenced (i.e. the child object).")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'del', obj: objectId, key: key }")),(0,o.kt)("p",{parentName:"li"},"The user deleted a key from a map, a row from a table, or an element from a\nlist or text object. ",(0,o.kt)("inlineCode",{parentName:"p"},"obj")," is the UUID of the object being modified. ",(0,o.kt)("inlineCode",{parentName:"p"},"key"),"\nis the key being removed from the map, the primary key of the row being\nremoved from the table, or the ID of the list/text element being removed,\nas appropriate.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"{ action: 'inc', obj: objectId, key: key, value: number }")),(0,o.kt)("p",{parentName:"li"},"The user incremented or decremented the value of an ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.Counter"),".\n",(0,o.kt)("inlineCode",{parentName:"p"},"obj")," is the UUID of the parent object being modified, and ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," is the name\nof the property or the list element ID where the counter is located within\nthat object. ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," is the amount by which the counter is incremented, with\na negative value representing a decrement."))),(0,o.kt)("p",null,"For example, the following code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"Automerge.change(Automerge.init(), 'Create document', doc => doc.cards = [ { title: 'hello world' } ])\n")),(0,o.kt)("p",null,"generates the following JSON object describing the change:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"{ actor: 'be3a9238-66c1-4215-9694-8688f1162cea',        // actorId where this change originated\n  seq: 1,                                               // sequence number 1\n  deps: {},                                             // no dependencies on other changes\n  message: 'Create document',                           // human-readable description\n  ops:\n   [ { action: 'makeList',                              // Make a list object to hold the cards\n       obj: '3a64c13f-c270-4af4-a733-abaadc5e7c46' },   // New UUID for the list\n     { action: 'ins',                                   // Insert a new element into the list we created\n       obj: '3a64c13f-c270-4af4-a733-abaadc5e7c46',     // UUID of the list object\n       key: '_head',                                    // Insert at the beginning of the list\n       elem: 1 },\n     { action: 'makeMap',                               // Make a map object to reprsent a card\n       obj: '4f1cd0ee-3855-4b56-9b8d-85f88cd614e3' },   // New UUID for the card\n     { action: 'set',                                   // Set the title of the card\n       obj: '4f1cd0ee-3855-4b56-9b8d-85f88cd614e3',     // UUID of the card object\n       key: 'title',\n       value: 'hello world' },\n     { action: 'link',                                  // Make the card the first element of the list\n       obj: '3a64c13f-c270-4af4-a733-abaadc5e7c46',     // UUID of the list object\n       key: 'be3a9238-66c1-4215-9694-8688f1162cea:1',   // Assign to the list element with elem:1\n       value: '4f1cd0ee-3855-4b56-9b8d-85f88cd614e3' }, // UUID of the card object\n     { action: 'link',                                  // Place the list of cards in the root object\n       obj: '00000000-0000-0000-0000-000000000000',     // UUID of the root object (hard-coded)\n       key: 'cards',\n       value: '3a64c13f-c270-4af4-a733-abaadc5e7c46' } ] }\n")),(0,o.kt)("h2",{id:"frontend-backend-protocol"},"Frontend-backend protocol"),(0,o.kt)("p",null,"Internally, most of Automerge is split into two major parts: a frontend and a\nbackend. The source code is organised into two directories with these names.\nThe idea behind this split is that the two parts can run on two separate\nthreads: the frontend runs as part of the user application on the render thread,\nwhile the backend can run in a background thread, e.g. as a\n",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"},"web worker"),".\nThis allows the backend to perform computationally expensive tasks without\naffecting the responsiveness of the user interface."),(0,o.kt)("p",null,"If you use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.{init,load,change,...}")," APIs, you don't see the\nfrontend/backend distinction, and both just run on the same thread (the frontend\ncommunicates with the backend by just calling its functions directly). If you\nwant to run them on separate threads, you need to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.Frontend.*"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.Backend.*")," APIs instead, and you will have to wire up the\ninter-thread communication yourself."),(0,o.kt)("p",null,"The communication between frontend and backend is by asynchronous\nmessage-passing, and the messages consist only of regular JavaScript objects and\narrays (no instances of any other classes), so they can be serialized to JSON if\nnecessary. This design also opens up the possibility of frontend and backend\nbeing implemented in different languages. The only requirement is that messages\nbetween frontend and backend must be received in the order they were sent \u2014\nreordering is not allowed."),(0,o.kt)("p",null,"Changes that are made by the local user are first made to the frontend, and then\nsent to the backend; the backend processes the change, and then sends a\nconfirmation back to the frontend. When changes arrive over the network from\nremote users, they are first processed by the backend, and then sent to the\nfrontend to update its state."),(0,o.kt)("p",null,"Messages from the frontend to the backend are called ",(0,o.kt)("strong",{parentName:"p"},"change requests")," (as\nthey always represent a change made by the local user, via\n",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.{change,undo,redo}"),"). Messages from the backend to the frontend are\ncalled ",(0,o.kt)("strong",{parentName:"p"},"patches")," (because they describe a modification that needs to be made\nto the frontend state)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"NB. This section describes the frontend/backend communication protocol used by\nthe currently released version of Automerge (on the ",(0,o.kt)("inlineCode",{parentName:"strong"},"main")," branch). An updated\nprotocol has been implemented on the ",(0,o.kt)("inlineCode",{parentName:"strong"},"performance")," branch).")),(0,o.kt)("h3",{id:"change-requests"},"Change requests"),(0,o.kt)("p",null,"Change requests (sent from frontend to backend) are generated by\n",(0,o.kt)("inlineCode",{parentName:"p"},"Frontend.from()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Frontend.change()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Frontend.emptyChange()"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"Frontend.undo()"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"Frontend.redo()"),". Change requests look very similar to\nchanges: they have properties ",(0,o.kt)("inlineCode",{parentName:"p"},"actor"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"seq"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"deps"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"message"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"ops")," as\ndocumented above. The difference is that there is one additional property\n",(0,o.kt)("inlineCode",{parentName:"p"},"requestType"),", whose value must be either ",(0,o.kt)("inlineCode",{parentName:"p"},"'change'"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"'undo'"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"'redo'"),"."),(0,o.kt)("p",null,"In the case of ",(0,o.kt)("inlineCode",{parentName:"p"},"'change'"),", the other properties describe the change by the local\nuser that should be applied to the backend state. In the case of a ",(0,o.kt)("inlineCode",{parentName:"p"},"requestType"),"\nof ",(0,o.kt)("inlineCode",{parentName:"p"},"'undo'")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"'redo'"),", the change request does not contain any ",(0,o.kt)("inlineCode",{parentName:"p"},"ops")," property\n(but the other properties ",(0,o.kt)("inlineCode",{parentName:"p"},"actor"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"seq"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"deps"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"message")," are still\npresent). In this case, the list of ops is filled in by the backend (since the\nbackend maintains the undo/redo history)."),(0,o.kt)("p",null,"A change request from the frontend is applied to the backend using\n",(0,o.kt)("inlineCode",{parentName:"p"},"Backend.applyLocalChange()"),", and the backend responds with a patch describing\nthe change."),(0,o.kt)("h3",{id:"patch-format"},"Patch format"),(0,o.kt)("p",null,"Three backend functions generate patches: ",(0,o.kt)("inlineCode",{parentName:"p"},"Backend.applyLocalChange()")," takes\na change request from the frontend, applies it, and returns a patch confirming\nthe change; ",(0,o.kt)("inlineCode",{parentName:"p"},"Backend.applyChanges()")," applies a set of existing changes (which\nmay be loaded from disk or received over the network) and returns a patch\ndescribing the modifications made by those changes; and ",(0,o.kt)("inlineCode",{parentName:"p"},"Backend.getPatch()"),"\nreturns a patch that creates a new document from scratch, reflecting the current\nbackend state."),(0,o.kt)("p",null,"On the frontend, ",(0,o.kt)("inlineCode",{parentName:"p"},"Frontend.applyPatch()")," applies a patch to an Automerge\ndocument, returning an updated document."),(0,o.kt)("p",null,"A patch is a JSON object with the following properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"actor")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"seq"),": If the patch is a response to a change request, these\nproperties are set to match the ",(0,o.kt)("inlineCode",{parentName:"li"},"actor")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"seq")," in the change request.\nNot set on patches generated by ",(0,o.kt)("inlineCode",{parentName:"li"},"applyChanges()")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"getPatch()"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"canUndo")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"canRedo"),": Booleans that indicate whether, after applying this\npatch, ",(0,o.kt)("inlineCode",{parentName:"li"},"undo()")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"redo()")," should be enabled, respectively. Undo is enabled\nif there is at least one local change that has not been undone, and redo is\nenabled if there has been at least one undo since the last change."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"clock")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"deps"),": Objects in which the keys are actor IDs, and the values\nare the highest sequence number that the backend has processed from that\nactor. The difference between ",(0,o.kt)("inlineCode",{parentName:"li"},"clock")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"deps")," is that ",(0,o.kt)("inlineCode",{parentName:"li"},"clock")," contains all\nactor IDs ever seen by the backend, while ",(0,o.kt)("inlineCode",{parentName:"li"},"deps")," contains only direct\ndependencies that cannot be reached transitively via one of the other\ndependencies. The frontend should include ",(0,o.kt)("inlineCode",{parentName:"li"},"deps")," in the next change request\nit sends to the backend."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"diffs"),": An array of diffs, where each diff describes a modification to the\ndocument. A diff is similar in purpose to an operation, but they differ in\nthe details, as shown below. (Terminology: a diff is contained in a patch,\nwhile an operation is contained in a change.) Diffs must be applied to the\ndocument in the order in which they appear in this array.")),(0,o.kt)("p",null,"A diff is a JSON object with the following properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"obj"),": The UUID of the object being updated.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"type"),": The type of object being updated, which must be one of ",(0,o.kt)("inlineCode",{parentName:"p"},"'map'"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"'table'"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"'list'"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"'text'"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"path"),": The path from the root of the document to the object being updated,\ngiven as an array. The empty array refers to the root object. Otherwise, read\nthe array from left to right to traverse from the root object to ",(0,o.kt)("inlineCode",{parentName:"p"},"obj"),". When\nthe object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),", the path element is the name of the property to\nnavigate to. When the object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"table"),", the path element is the primary key\nof the row. When the object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"text"),", the path element is the\ninteger index of the list element. The entire path may be ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if the object\nis not reachable from the document root.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"action"),": If the object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"table"),", the action is either\n",(0,o.kt)("inlineCode",{parentName:"p"},"'create'"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"'set'"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"'remove'"),". If the object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"text"),", the\naction is one of ",(0,o.kt)("inlineCode",{parentName:"p"},"'create'"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"'insert'"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"'set'"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"'remove'"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"'maxElem'"),".\nThe action types are explained below.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"key"),": Used when the object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"table"),", and when the action is\n",(0,o.kt)("inlineCode",{parentName:"p"},"set")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"remove"),". Indicates the name of the property (in the case of a ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),")\nor the primary key of the row (in the case of a ",(0,o.kt)("inlineCode",{parentName:"p"},"table"),") that should be\nupdated or removed.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"index"),": Used when the object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"text"),", and when the action is\none of ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"set"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"remove"),". Indicates the integer list index where\na new element should be inserted, or where the value should be updated, or\nthat should be removed, respectively.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"elemId"),": Used when the object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"text"),", and when the action is\n",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),". This property contains the element ID of the newly inserted element,\nas a string of the form ",(0,o.kt)("inlineCode",{parentName:"p"},"'actorId:integer'"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"value")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"link"),": Used when the action is ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),". Which property\nis used depends on whether the value assigned or inserted in this action is\na primitive value (number, string, boolean, or null, in which case the ",(0,o.kt)("inlineCode",{parentName:"p"},"value"),"\nproperty is used), or another object (in which case the ",(0,o.kt)("inlineCode",{parentName:"p"},"link")," property\ncontains the object ID of the object assigned in this action)."),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," property is also used when the action is ",(0,o.kt)("inlineCode",{parentName:"p"},"maxElem"),". In this case,\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," property contains the highest ",(0,o.kt)("inlineCode",{parentName:"p"},"elem")," integer that has appeared in\nany ",(0,o.kt)("inlineCode",{parentName:"p"},"ins")," operation (see documentation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ins")," operation). This action\nensures that the same element ID is not reused in certain edge cases.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"datatype"),": Used when the action is ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),", and the ",(0,o.kt)("inlineCode",{parentName:"p"},"value"),"\nproperty is set. The value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"datatype")," property is either ",(0,o.kt)("inlineCode",{parentName:"p"},"'timestamp'"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"'counter'"),", or the property is absent. The meaning is as documented for the\n",(0,o.kt)("inlineCode",{parentName:"p"},"set")," operation.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"conflicts"),": Used when the action is ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),". If present, the value\nis an array of objects, where each object represents a conflicting value that\nwas concurrently assigned to this property or list index. Each object in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"conflicts")," array has a property ",(0,o.kt)("inlineCode",{parentName:"p"},"actor")," containing the ID of the actor that\nassigned this value. In addition, the object has either a ",(0,o.kt)("inlineCode",{parentName:"p"},"link")," property\n(containing the object ID of the nested object that was assigned), or ",(0,o.kt)("inlineCode",{parentName:"p"},"value"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"datatype")," properties (containing the primitive value, and optionally the\ndatatype interpretation, that was assigned)."))),(0,o.kt)("h2",{id:"applying-operations-to-the-backend"},"Applying operations to the backend"),(0,o.kt)("p",null,"The local state in the backend is comprised of a few different pieces:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"queue"),": A list of pending changes that have not yet been applied because some\nof their dependencies are missing."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"history"),": A list of all applied changes.")),(0,o.kt)("p",null,"The two pieces of state above represent the single source-of-truth for every\nchange that the system has observed. When saving and loading an Automerge CRDT,\nonly the ",(0,o.kt)("inlineCode",{parentName:"p"},"history")," is used. The pieces described below contain cached information\nthat would otherwise have to be computed by iterating over the entire history."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"states"),": A map keyed by actor IDs. The values are lists of the form\n",(0,o.kt)("inlineCode",{parentName:"li"},"[{change: change1, allDeps: allDeps1}, {change: ..., allDeps: ...}, ...]"),",\nwhere the n-th object in the list contains the change with sequence number n+1\nby that actor, and ",(0,o.kt)("inlineCode",{parentName:"li"},"allDeps")," is the full vector clock of dependencies (and\ntransitive dependencies) of that change."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"byObject"),": A map keyed by object ID, where each value is a map containing the\nfollowing keys:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_init"),": The operation that created this object (an object whose ",(0,o.kt)("inlineCode",{parentName:"li"},"action"),"\nproperty is one of ",(0,o.kt)("inlineCode",{parentName:"li"},"makeMap"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"makeList"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"makeTable"),", or ",(0,o.kt)("inlineCode",{parentName:"li"},"makeText"),")."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_keys"),": A map where the keys are property names (in the case of a map\nobject), row primary keys (in the case of a table object), or element IDs\n(in the case of a list or text object). The value for each key is a list of\noperations that assign a value to this key. In the common case, there is\neither no operation (indicating the absence of a value, e.g. a tombstone in\na list), or one operation (containing the current value of this property).\nMultiple operations appear in this list if there were conflicting,\nconcurrent assignments to the same element."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_inbound"),": The set of ",(0,o.kt)("inlineCode",{parentName:"li"},"link")," operations whose value is this object ID; in\nother words, the set of operations that establish a link between this\nobject and its parents. Normally an object may appear only once in the\ntree, in which case it has exactly one parent, and this set contains\nexactly one operation. The set is empty if the object is the root object,\nor if it is removed from the tree."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_insertion"),": Used in list and text objects only. A map whose keys are the\nlist element IDs, and the value for each key is the ",(0,o.kt)("inlineCode",{parentName:"li"},"ins")," operation that\ninserted the element with that ID."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_following"),": Used in list and text objects only. A map whose keys are list\nelement IDs, or the string ",(0,o.kt)("inlineCode",{parentName:"li"},"'_head'"),", and the value for each key is a list\nof ",(0,o.kt)("inlineCode",{parentName:"li"},"ins")," operations that reference that key in their ",(0,o.kt)("inlineCode",{parentName:"li"},"key")," property. There\nmay be multiple such operations if there have been multiple insertions at\nthe same place in the list."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_elemIds"),": Used in list and text objects only. An instance of the\n",(0,o.kt)("inlineCode",{parentName:"li"},"SkipList")," class, containing the sequence of element IDs of visible elements\nin the list (i.e. element IDs that have at least one associated value).\nThis skip list is used to efficiently translate between element IDs and\nlist indexes."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"clock"),": A map where keys are actor IDs, and the value is the highest change\nsequence number that we have applied from that actor. This represents the\ncurrent vector clock of the local state, containing all actor IDs ever seen."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"deps"),": A map of the same form as ",(0,o.kt)("inlineCode",{parentName:"li"},"clock"),", but excluding transitive\ndependencies \u2014 that is, containing only actorID/seqNo pairs that cannot be\nreached through the indirect dependencies of another of the dependencies."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"undoPos"),": An integer, representing the current place in the undo stack. At\nany point in time, the first ",(0,o.kt)("inlineCode",{parentName:"li"},"undoPos")," elements of ",(0,o.kt)("inlineCode",{parentName:"li"},"undoStack")," (i.e. indexes\n0 to undoPos\u20131) are undoable, and any indexes >= undoPos in ",(0,o.kt)("inlineCode",{parentName:"li"},"undoStack")," have\nalready been undone."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"undoStack"),": A list of list of operations. One element in the outer list is\npushed when a local change is performed through ",(0,o.kt)("inlineCode",{parentName:"li"},"applyLocalChange()"),", and it\nis set to the list of operations that need to be performed in order to undo\nthat change. Those operations are chosen such that they restore the prior\nvalue(s) of any properties that are updated in the course of the local change."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"redoStack"),": A list of list of operations, similar to ",(0,o.kt)("inlineCode",{parentName:"li"},"undoStack"),". Here, an\nelement is pushed to the outer list when an undo is performed, and it\ncontains the operations that we need to perform in order to undo the undo.")))}c.isMDXComponent=!0}}]);