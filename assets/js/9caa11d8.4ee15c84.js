"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8353],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,h=p["".concat(i,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=p;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:o,s[1]=l;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5732:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return i},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),s=["components"],l={sidebar_position:7},i="Multi-user apps",c={unversionedId:"tutorial/sync-changes",id:"tutorial/sync-changes",isDocsHomePage:!1,title:"Multi-user apps",description:"Until now, you've built an Automerge application for a single user only. But Automerge excels when there are multiple users editing a document over time, with our without the Internet or connection to each other.",source:"@site/docs/tutorial/sync-changes.md",sourceDirName:"tutorial",slug:"/tutorial/sync-changes",permalink:"/docs/tutorial/sync-changes",editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/tutorial/sync-changes.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Save and Load",permalink:"/docs/tutorial/save-and-load"},next:{title:"Remote storage",permalink:"/docs/tutorial/remote-storage"}},u=[{value:"BroadcastChannel",id:"broadcastchannel",children:[],level:2},{value:"Generating a sync message",id:"generating-a-sync-message",children:[],level:2},{value:"Receiving a sync message",id:"receiving-a-sync-message",children:[],level:2},{value:"Hints",id:"hints",children:[],level:2}],d={toc:u};function p(e){var t=e.components,n=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"multi-user-apps"},"Multi-user apps"),(0,r.kt)("p",null,"Until now, you've built an Automerge application for a single user only. But Automerge excels when there are multiple users editing a document over time, with our without the Internet or connection to each other."),(0,r.kt)("h2",{id:"broadcastchannel"},"BroadcastChannel"),(0,r.kt)("p",null,"In this tutorial, we will use a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel"},"BroadcastChannel"),", which allows you to simulate a local area network. All tabs and windows on the same domain in the browser will be able to send and receive messages from each other. In a production application, you could use a WebSocket, WebRTC server, HTTP server, or simply send binary files around. "),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: BroadcastChannel is not available in IE or Safari. You must install the Safari Technical Preview or use another browser, such as Chrome, Brave, or Firefox.")),(0,r.kt)("p",null,"Each channel has it's own id. We use the ",(0,r.kt)("inlineCode",{parentName:"p"},"docId"),", which allows us to send messages to any other browser tab or iframe that has the id."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let docId = window.location.hash\nlet channel = new BroadcastChannel(docId)\n")),(0,r.kt)("p",null,"Then, we initialize the Automerge SyncState. In a production application, you'd have one sync state for each peer, but for the purposes of our tutorial, this will work for one peer at a time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let doc = Automerge.init()\nlet syncState = Automerge.initSyncState()\n")),(0,r.kt)("h2",{id:"generating-a-sync-message"},"Generating a sync message"),(0,r.kt)("p",null,"Every time we change the document locally, we need to update all of our peers with the latest document state. You do this by generating a sync message:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let [nextSyncState, msg] = Automerge.generateSyncMessage(doc, syncState)\n")),(0,r.kt)("p",null,"You then send ",(0,r.kt)("inlineCode",{parentName:"p"},"msg")," over the channel, using ",(0,r.kt)("inlineCode",{parentName:"p"},"channel.postMessage"),". If ",(0,r.kt)("inlineCode",{parentName:"p"},"msg")," is null, there is nothing to send."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"channel.postMessage(msg)\n")),(0,r.kt)("p",null,"So, the full code is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let syncState = Automerge.initSyncState()\nobserver.observe(doc, (diff, before, after, local, changes) => {\n    render(after)\n    save(after)\n    updatePeers(after)\n})\n\nfunction updatePeers (doc) {\n    let [nextSyncState, msg] = Automerge.generateSyncMessage(doc, syncState)\n    syncState = nextSyncState\n    if (msg) channel.postMessage(msg)\n}\n")),(0,r.kt)("p",null,"To check to see if this worked, we need to listen to changes to see if they're being sent. The channel has an ",(0,r.kt)("inlineCode",{parentName:"p"},"onmessage")," event, which fires every time ",(0,r.kt)("inlineCode",{parentName:"p"},"postMessage")," is called. "),(0,r.kt)("p",null,"Add this to your code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"channel.onmessage = (ev) => {\n    let payload = ev.data\n    console.log(payload)\n}\n")),(0,r.kt)("p",null,"Now, test it! Copy and paste your url into a new window so that you have two windows or tabs with the same docId. In one browser tab, add a new item. Do you see a console.log message on the other side?"),(0,r.kt)("h2",{id:"receiving-a-sync-message"},"Receiving a sync message"),(0,r.kt)("p",null,"Great, now that we are sending sync messages, we have to do something with them. Automerge provides a function ",(0,r.kt)("inlineCode",{parentName:"p"},"Automerge.receiveSyncMessage")," which processes the message and generates a new document & sync state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let [ newDoc, newSyncState, ] = Automerge.receiveSyncMessage(doc, syncState, payload.msg)\ndoc = newDoc\nsyncState = newSyncState\n")),(0,r.kt)("p",null,"Great, so we have a new document which we can render. You can check to see if this actually works. Since you reassign the document, the observer callback will get called and so your front-end should re-render and save the new document state."),(0,r.kt)("p",null,"However, we need to finish the sync process. Sync is not just a one-way update, it is a multi-party state management protocol. For example, if one side has many updates to send, not all of the updates will be sent in one single sync message. One side may have also received changes from a third party, which should be sent back. This means that every time we receive a sync message, we should generate the next sync message, until ",(0,r.kt)("inlineCode",{parentName:"p"},"generateSyncMessage")," returns null. When generateSyncMessage returns null, that means we are all up to date."),(0,r.kt)("p",null,"The final resulting code looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"channel.onmessage = function (ev) {\n    let payload = ev.data\n\n    // this message is from the same actor, ignore it\n    if (payload.actorId === Automerge.getActorId(doc)) return \n    let [ newDoc, newSyncState, ] = Automerge.receiveSyncMessage(doc, syncState, payload.msg)\n    doc = newDoc\n    syncState = newSyncState\n    // updatePeers again, until sync message is null and then we will stop\n    updatePeers(doc)\n}\n\nfunction updatePeers (doc) {\n    let actorId = Automerge.getActorId(doc)\n    let [nextSyncState, msg] = Automerge.generateSyncMessage(\n        doc, \n        syncState\n    )\n    syncState = nextSyncState\n    if (msg) {\n        channel.postMessage({\n            actorId,\n            msg: msg\n        })\n    }\n}\n")),(0,r.kt)("p",null,"Now, you should be able to add and toggle todo items on both sides and see the changes!"),(0,r.kt)("p",null,"For more information about the sync protocol, and a more advanced example for multiple peers, see the ",(0,r.kt)("a",{parentName:"p",href:"/docs/cookbook/real-time"},"Cookbook"),"."),(0,r.kt)("h2",{id:"hints"},"Hints"),(0,r.kt)("p",null,"Make sure you always update the global ",(0,r.kt)("inlineCode",{parentName:"p"},"doc")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"sycnState")," with the latest versions whenever there is a new sync message."))}p.isMDXComponent=!0}}]);