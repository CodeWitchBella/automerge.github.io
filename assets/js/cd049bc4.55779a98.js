"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5445],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=l(n),p=o,g=m["".concat(s,".").concat(p)]||m[p]||u[p]||r;return n?a.createElement(g,c(c({ref:t},d),{},{components:n})):a.createElement(g,c({ref:t},d))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,c=new Array(r);c[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,c[1]=i;for(var l=2;l<r;l++)c[l]=n[l];return a.createElement.apply(null,c)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5680:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var a=n(7462),o=(n(7294),n(3905));const r={id:"index",title:"@automerge/automerge",sidebar_label:"Overview",sidebar_position:0,custom_edit_url:null},c="Automerge",i={unversionedId:"tsapi/index",id:"tsapi/index",isDocsHomePage:!1,title:"@automerge/automerge",description:"This library provides the core automerge data structure and sync algorithms.",source:"@site/docs/tsapi/index.md",sourceDirName:"tsapi",slug:"/tsapi/index",permalink:"/docs/tsapi/index",editUrl:null,tags:[],version:"current",sidebarPosition:0,frontMatter:{id:"index",title:"@automerge/automerge",sidebar_label:"Overview",sidebar_position:0,custom_edit_url:null},sidebar:"tutorialSidebar",previous:{title:"Sync Protocol",permalink:"/docs/how-it-works/sync"},next:{title:"Exports",permalink:"/docs/tsapi/modules"}},s=[{value:"Creating and modifying a document",id:"creating-and-modifying-a-document",children:[],level:2},{value:"Applying changes from another document",id:"applying-changes-from-another-document",children:[],level:2},{value:"Saving and loading documents",id:"saving-and-loading-documents",children:[],level:2},{value:"Syncing",id:"syncing",children:[],level:2},{value:"Conflicts",id:"conflicts",children:[],level:2},{value:"Actor IDs",id:"actor-ids",children:[],level:2},{value:"Listening to patches",id:"listening-to-patches",children:[],level:2},{value:"Cloning",id:"cloning",children:[],level:2}],l={toc:s};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"automerge"},"Automerge"),(0,o.kt)("p",null,"This library provides the core automerge data structure and sync algorithms.\nOther libraries can be built on top of this one which provide IO and\npersistence."),(0,o.kt)("p",null,"An automerge document can be though of an immutable POJO (plain old javascript\nobject) which ",(0,o.kt)("inlineCode",{parentName:"p"},"automerge")," tracks the history of, allowing it to be merged with\nany other automerge document."),(0,o.kt)("h2",{id:"creating-and-modifying-a-document"},"Creating and modifying a document"),(0,o.kt)("p",null,"You can create a document with ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#init"},"init")," or ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#from"},"from")," and then make\nchanges to it with ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#change-1"},"change"),", you can merge two documents with ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#merge"},"merge"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'import * as automerge from "@automerge/automerge"\n\ntype DocType = {ideas: Array<automerge.Text>}\n\nlet doc1 = automerge.init<DocType>()\ndoc1 = automerge.change(doc1, d => {\n    d.ideas = [new automerge.Text("an immutable document")]\n})\n\nlet doc2 = automerge.init<DocType>()\ndoc2 = automerge.merge(doc2, automerge.clone(doc1))\ndoc2 = automerge.change<DocType>(doc2, d => {\n    d.ideas.push(new automerge.Text("which records it\'s history"))\n})\n\n// Note the `automerge.clone` call, see the "cloning" section of this readme for\n// more detail\ndoc1 = automerge.merge(doc1, automerge.clone(doc2))\ndoc1 = automerge.change(doc1, d => {\n    d.ideas[0].deleteAt(13, 8)\n    d.ideas[0].insertAt(13, "object")\n})\n\nlet doc3 = automerge.merge(doc1, doc2)\n// doc3 is now {ideas: ["an immutable object", "which records it\'s history"]}\n')),(0,o.kt)("h2",{id:"applying-changes-from-another-document"},"Applying changes from another document"),(0,o.kt)("p",null,"You can get a representation of the result of the last ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#change-1"},"change")," you made\nto a document with ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#getlastlocalchange"},"getLastLocalChange")," and you can apply that change to\nanother document using ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#applychanges"},"applyChanges"),"."),(0,o.kt)("p",null,"If you need to get just the changes which are in one document but not in another\nyou can use ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#getheads"},"getHeads")," to get the heads of the document without the\nchanges and then ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#getmissingdeps"},"getMissingDeps"),", passing the result of ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#getheads"},"getHeads"),"\non the document with the changes."),(0,o.kt)("h2",{id:"saving-and-loading-documents"},"Saving and loading documents"),(0,o.kt)("p",null,"You can ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#save"},"save")," a document to generate a compresed binary representation of\nthe document which can be loaded with ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#load"},"load"),". If you have a document which\nyou have recently made changes to you can generate recent changes with saveIncremental, this will generate all the changes since you last called\n",(0,o.kt)("inlineCode",{parentName:"p"},"saveIncremental"),", the changes generated can be applied to another document with\n",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#loadincremental"},"loadIncremental"),"."),(0,o.kt)("h2",{id:"syncing"},"Syncing"),(0,o.kt)("p",null,"The sync protocol is stateful. This means that we start by creating a ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/interfaces/SyncState"},"SyncState")," for each peer we are communicating with using ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#initsyncstate"},"initSyncState"),".\nThen we generate a message to send to the peer by calling ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#generatesyncmessage"},"generateSyncMessage"),". When we receive a message from the peer we call ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#receivesyncmessage"},"receiveSyncMessage"),". Here's a simple example of a loop which just keeps two\npeers in sync."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"let sync1 = automerge.initSyncState()\nlet msg: Uint8Array | null\n[sync1, msg] = automerge.generateSyncMessage(doc1, sync1)\n\nwhile (true) {\n    if (msg != null) {\n        network.send(msg)\n    }\n    let resp: Uint8Array = network.receive()\n    [doc1, sync1, _ignore] = automerge.receiveSyncMessage(doc1, sync1, resp)\n    [sync1, msg] = automerge.generateSyncMessage(doc1, sync1)\n}\n")),(0,o.kt)("h2",{id:"conflicts"},"Conflicts"),(0,o.kt)("p",null,"The only time conflicts occur in automerge documents is in concurrent\nassignments to the same key in an object. In this case automerge\ndeterministically chooses an arbitrary value to present to the application but\nyou can examine the conflicts using ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#getconflicts"},"getConflicts"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import * as automerge from "@automerge/automerge"\n\ntype Profile = {\n    pets: Array<{name: string, type: string}>\n}\n\nlet doc1 = automerge.init<Profile>("aaaa")\ndoc1 = automerge.change(doc1, d => {\n    d.pets = [{name: "Lassie", type: "dog"}]\n})\nlet doc2 = automerge.init<Profile>("bbbb")\ndoc2 = automerge.merge(doc2, automerge.clone(doc1))\n\ndoc2 = automerge.change(doc2, d => {\n    d.pets[0].name = "Beethoven"\n})\n\ndoc1 = automerge.change(doc1, d => {\n    d.pets[0].name = "Babe"\n})\n\nconst doc3 = automerge.merge(doc1, doc2)\n\n// Note that here we pass `doc3.pets`, not `doc3`\nlet conflicts = automerge.getConflicts(doc3.pets[0], "name")\n\n// The two conflicting values are the keys of the conflicts object\nassert.deepEqual(Object.values(conflicts), ["Babe", Beethoven"])\n')),(0,o.kt)("h2",{id:"actor-ids"},"Actor IDs"),(0,o.kt)("p",null,"By default automerge will generate a random actor ID for you, but most methods\nfor creating a document allow you to set the actor ID. You can get the actor ID\nassociated with the document by calling ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#getactorid"},"getActorId"),". Actor IDs must not\nbe used in concurrent threads of executiong - all changes by a given actor ID\nare expected to be sequential. "),(0,o.kt)("h2",{id:"listening-to-patches"},"Listening to patches"),(0,o.kt)("p",null,"Sometimes you want to respond to changes made to an automerge document. In this\ncase you can use the ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#patchcallback"},"PatchCallback")," type to receive notifications when\nchanges have been made."),(0,o.kt)("h2",{id:"cloning"},"Cloning"),(0,o.kt)("p",null,"Currently you cannot make mutating changes (i.e. call ",(0,o.kt)("a",{parentName:"p",href:"/docs/tsapi/modules#change-1"},"change"),") to a\ndocument which you have two pointers to. For example, in this code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'let doc1 = automerge.init()\nlet doc2 = automerge.change(doc1, d => d.key = "value")\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"doc1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"doc2")," are both pointers to the same state. Any attempt to call\nmutating methods on ",(0,o.kt)("inlineCode",{parentName:"p"},"doc1")," will now result in an error like"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Attempting to change an out of date document\n")),(0,o.kt)("p",null,"If you encounter this you need to clone the original document, the above sample\nwould work as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'let doc1 = automerge.init()\nlet doc2 = automerge.change(automerge.clone(doc1), d => d.key = "value")\n')))}d.isMDXComponent=!0}}]);