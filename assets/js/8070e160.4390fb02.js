"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2651],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=r,g=p["".concat(s,".").concat(d)]||p[d]||m[d]||o;return n?a.createElement(g,i(i({ref:t},u),{},{components:n})):a.createElement(g,i({ref:t},u))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9443:(e,t,n)=>{n.d(t,{Z:()=>a});const a=(0,n(7294).createContext)(void 0)},9053:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>j,default:()=>x,frontMatter:()=>N,metadata:()=>C,toc:()=>T});var a=n(7462),r=n(7294),o=n(3905),i=n(2389),l=n(9443);const s=function(){const e=(0,r.useContext)(l.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e};var c=n(9521),u=n(6010);const p="tabItem_vU9c";function m(e){const{lazy:t,block:n,defaultValue:a,values:o,groupId:i,className:l}=e,m=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),d=o??m.map((e=>{let{props:{value:t,label:n}}=e;return{value:t,label:n}})),g=(0,c.lx)(d,((e,t)=>e.value===t.value));if(g.length>0)throw new Error(`Docusaurus error: Duplicate values "${g.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===a?a:a??m.find((e=>e.props.default))?.props.value??m[0]?.props.value;if(null!==h&&!d.some((e=>e.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${d.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:f}=s(),[y,b]=(0,r.useState)(h),v=[],{blockElementScrollPositionUntilNextRender:w}=(0,c.o5)();if(null!=i){const e=k[i];null!=e&&e!==y&&d.some((t=>t.value===e))&&b(e)}const N=e=>{const t=e.currentTarget,n=v.indexOf(t),a=d[n].value;a!==y&&(w(t),b(a),null!=i&&f(i,a))},j=e=>{let t=null;switch(e.key){case"ArrowRight":{const n=v.indexOf(e.currentTarget)+1;t=v[n]||v[0];break}case"ArrowLeft":{const n=v.indexOf(e.currentTarget)-1;t=v[n]||v[v.length-1];break}}t?.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,u.Z)("tabs",{"tabs--block":n},l)},d.map((e=>{let{value:t,label:n}=e;return r.createElement("li",{role:"tab",tabIndex:y===t?0:-1,"aria-selected":y===t,className:(0,u.Z)("tabs__item",p,{"tabs__item--active":y===t}),key:t,ref:e=>v.push(e),onKeyDown:j,onFocus:N,onClick:N},n??t)}))),t?(0,r.cloneElement)(m.filter((e=>e.props.value===y))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},m.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==y})))))}function d(e){const t=(0,i.Z)();return r.createElement(m,(0,a.Z)({key:String(t)},e))}const g=function(e){let{children:t,hidden:n,className:a}=e;return r.createElement("div",{role:"tabpanel",hidden:n,className:a},t)},h={toc:[]};function k(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Enable the ",(0,o.kt)("inlineCode",{parentName:"p"},"asyncWebAssembly"),"\n",(0,o.kt)("a",{parentName:"p",href:"https://webpack.js.org/configuration/experiments/"},"experiment"),". For example:"),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"webpack.config.js")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const path = require('path');\n\nmodule.exports = {\n  experiments: { asyncWebAssembly: true },\n  target: 'web',\n  entry: './src/index.js',\n  output: {\n    filename: 'main.js',\n    path: path.resolve(__dirname, 'public'),\n  },\n  mode: \"development\", // or production\n  performance: {       // we dont want the wasm blob to generate warnings\n     hints: false,\n     maxEntrypointSize: 512000,\n     maxAssetSize: 512000\n  }\n};\n")))}k.isMDXComponent=!0;const f={toc:[]};function y(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"There are three things you need to do to get WASM packaging working with vite:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Install the top level await plugin"),(0,o.kt)("li",{parentName:"ol"},"Install the ",(0,o.kt)("inlineCode",{parentName:"li"},"vite-plugin-wasm")," plugin"),(0,o.kt)("li",{parentName:"ol"},"Exclude ",(0,o.kt)("inlineCode",{parentName:"li"},"automerge-wasm")," from the optimizer")),(0,o.kt)("p",null,"First, install the packages we need:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add vite-plugin-top-level-await\nyarn add vite-plugin-wasm\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"vite.config.js")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'import { defineConfig } from "vite"\nimport wasm from "vite-plugin-wasm"\nimport topLevelAwait from "vite-plugin-top-level-await"\n\nexport default defineConfig({\n    plugins: [topLevelAwait(), wasm()],\n    \n    // This is only necessary if you are using `SharedWorker` or `WebWorker`, as \n    // documented in https://vitejs.dev/guide/features.html#import-with-constructors\n    worker: { \n        format: "es",\n        plugins: [topLevelAwait(), wasm()] \n    },\n\n    optimizeDeps: {\n        // This is necessary because otherwise `vite dev` includes two separate\n        // versions of the JS wrapper. This causes problems because the JS\n        // wrapper has a module level variable to track JS side heap\n        // allocations, initializing this twice causes horrible breakage\n        exclude: ["@automerge/automerge-wasm"]\n    }\n})\n')))}y.isMDXComponent=!0;const b={toc:[]};function v(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Assuming you have already run ",(0,o.kt)("inlineCode",{parentName:"p"},"create-react-app")," and your working directory is\nthe project."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add craco craco-wasm\n")),(0,o.kt)("p",null,"Modify ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," to use ",(0,o.kt)("inlineCode",{parentName:"p"},"craco")," for scripts. In ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," the\n",(0,o.kt)("inlineCode",{parentName:"p"},"scripts")," section will look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'  "scripts": {\n    "start": "create-react-app start",\n    "build": "create-react-app build",\n    "test": "create-react-app test",\n    "eject": "create-react-app eject"\n  },\n')),(0,o.kt)("p",null,"Replace that section with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'  "scripts": {\n    "start": "craco start",\n    "build": "craco build",\n    "test": "craco test",\n    "eject": "craco eject"\n  },\n')),(0,o.kt)("p",null,"In the root of the project add the following contents to ",(0,o.kt)("inlineCode",{parentName:"p"},"craco.config.js")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const cracoWasm = require("craco-wasm")\n\nmodule.exports = {\n    plugins: [cracoWasm()]\n}\n')))}function w(e){let{}=e;return[r.createElement(d,null,r.createElement(g,{value:"webpack",label:"Webpack 5"},r.createElement(k,null)),r.createElement(g,{value:"vite",label:"Vite"},r.createElement(y,null)),r.createElement(g,{value:"cra",label:"Create React App"},r.createElement(v,null)))]}v.isMDXComponent=!0;const N={sidebar_position:1},j="5-Minute Quick Start",C={unversionedId:"quickstart",id:"quickstart",isDocsHomePage:!1,title:"5-Minute Quick Start",description:"This guide will get you up and running with Automerge in a JavaScript or TypeScript application. This guide is recommended for you if you have strong understanding of JavaScript fundamentals and CRDTs. If you find this quick start to be complicated, we recommend trying the Tutorial section.",source:"@site/docs/quickstart.md",sourceDirName:".",slug:"/quickstart",permalink:"/docs/quickstart",editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/quickstart.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Welcome to Automerge",permalink:"/docs/hello"},next:{title:"Introduction",permalink:"/docs/tutorial/introduction"}},T=[{value:"Setup",id:"setup",children:[],level:2},{value:"Creating a document",id:"creating-a-document",children:[],level:2},{value:"Making changes",id:"making-changes",children:[],level:2},{value:"Merging documents",id:"merging-documents",children:[],level:2},{value:"Get change history",id:"get-change-history",children:[],level:2},{value:"More",id:"more",children:[],level:2}],A={toc:T};function x(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},A,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"5-minute-quick-start"},"5-Minute Quick Start"),(0,o.kt)("p",null,"This guide will get you up and running with Automerge in a JavaScript or TypeScript application. This guide is recommended for you if you have strong understanding of JavaScript fundamentals and CRDTs. If you find this quick start to be complicated, we recommend trying the ",(0,o.kt)("a",{parentName:"p",href:"/docs/tutorial/introduction/"},"Tutorial")," section."),(0,o.kt)("h2",{id:"setup"},"Setup"),(0,o.kt)("p",null,"Installation from ",(0,o.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/automerge"},"npm"),", using Node.js:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @automerge/automerge ## or yarn add @automerge/automerge\n")),(0,o.kt)("p",null,"Then load the library as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const Automerge = require('@automerge/automerge')\n")),(0,o.kt)("p",null,"If you are using ES2015 or TypeScript, import the library like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import * as Automerge from '@automerge/automerge'\n")),(0,o.kt)("p",null,"If you are in a browser you will need to setup a bundler to load WebAssembly modules, examples for three common examples are given below (more detailed working examples available ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/automerge/automerge-rs/tree/main/javascript/examples"},"in the repo"),"):"),(0,o.kt)(w,{mdxType:"Bundlers"}),(0,o.kt)("h2",{id:"creating-a-document"},"Creating a document"),(0,o.kt)("p",null,"Let's say doc1 is the application state on device 1. Further down we'll simulate a second device. We initialize the document to initially contain an empty list of cards."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"let doc1 = Automerge.init()\n")),(0,o.kt)("p",null,"Automerge follows good functional programming practice. The ",(0,o.kt)("inlineCode",{parentName:"p"},"doc1")," object is treated as immutable -- you  never change it directly. To change it, you need to call ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.change()")," with a callback in which you can mutate the state. "),(0,o.kt)("h2",{id:"making-changes"},"Making changes"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"doc1 = Automerge.change(doc1, 'Add card', doc => {\n  doc.cards = []\n  doc.cards.push({ title: 'Rewrite everything in Clojure', done: false })\n  doc.cards.push({ title: 'Rewrite everything in Haskell', done: false })\n})\n// { cards: [\n//    { title: 'Rewrite everything in Clojure', done: false },\n//    { title: 'Rewrite everything in Haskell', done: false } ]}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.change(doc, [message], changeFn)")," enables you to modify an Automerge document ",(0,o.kt)("inlineCode",{parentName:"p"},"doc"),",\nreturning an updated copy of the document."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"message")," argument is optional. It allows you to attach an arbitrary string to the change, which is not interpreted by Automerge, but saved as part of the change history."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"doc1")," returned by ",(0,o.kt)("inlineCode",{parentName:"p"},"Automerge.change()")," is a regular JavaScript object containing all the\nedits you made in the callback. Any parts of the document that you didn't change are carried over\nunmodified. The only special things about it are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"It is treated as immutable, so all changes must go through ",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.change()"),"."),(0,o.kt)("li",{parentName:"ul"},"Every object has a unique ID, which you can get by passing the object to the\n",(0,o.kt)("inlineCode",{parentName:"li"},"Automerge.getObjectId()")," function. This ID is used by Automerge to track which object is which."),(0,o.kt)("li",{parentName:"ul"},"Objects also have information about ",(0,o.kt)("em",{parentName:"li"},"conflicts"),", which is used when several users make changes to\nthe same property concurrently (see ",(0,o.kt)("a",{parentName:"li",href:"/docs/cookbook/conflicts/"},"conflicts"),"). ")),(0,o.kt)("h2",{id:"merging-documents"},"Merging documents"),(0,o.kt)("p",null,"Now let's simulate another device, whose application state is ",(0,o.kt)("inlineCode",{parentName:"p"},"doc2"),". We must\ninitialise it separately, and merge ",(0,o.kt)("inlineCode",{parentName:"p"},"doc1")," into it. After merging, ",(0,o.kt)("inlineCode",{parentName:"p"},"doc2")," is a replicated copy of ",(0,o.kt)("inlineCode",{parentName:"p"},"doc1"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"let doc2 = Automerge.init()\ndoc2 = Automerge.merge(doc2, doc1)\n")),(0,o.kt)("p",null,"You can also load the document as a binary, if you want to send the document over the network in a compact format, or if you want to save the document to disk."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"let binary = Automerge.save(doc1)\nlet doc2 = Automerge.load(binary)\n")),(0,o.kt)("p",null,"Now, when both documents are ready, we make separate (non-conflicting) changes. For handling conflicting changes, see the section on ",(0,o.kt)("a",{parentName:"p",href:"/docs/cookbook/conflicts/"},"conflicts"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"doc1 = Automerge.change(doc1, 'Mark card as done', doc => {\n  doc.cards[0].done = true\n})\ndoc2 = Automerge.change(doc2, 'Delete card', doc => {\n  delete doc.cards[1]\n})\n")),(0,o.kt)("p",null,"Now comes the moment of truth. Let's merge the changes again. You can also do the merge the other way around, and you'll get the same result. Order doesn't matter here. The merged result remembers that 'Rewrite everything in Clojure' was set to true, and that 'Rewrite everything in Haskell' was deleted:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"let finalDoc = Automerge.merge(doc1, doc2)\n// { cards: [ { title: 'Rewrite everything in Clojure', done: true } ] }\n")),(0,o.kt)("h2",{id:"get-change-history"},"Get change history"),(0,o.kt)("p",null,'As our final trick, we can inspect the change history. Automerge automatically\nkeeps track of every change, along with the "commit message" that you passed to\nchange(). When you query that history, it includes both changes you made\nlocally, and also changes that came from other devices. You can also see a\nsnapshot of the application state at any moment in time in the past. For\nexample, we can count how many cards there were at each point:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"Automerge.getHistory(finalDoc).map(state => [state.change.message, state.snapshot.cards.length])\n// [ [ 'Add card', 2 ],\n//   [ 'Mark card as done', 2 ],\n//   [ 'Delete card', 1 ] ]\n")),(0,o.kt)("h2",{id:"more"},"More"),(0,o.kt)("p",null,"If you're hungry for more, look in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/cookbook/modeling-data/"},"Cookbook")," section."))}x.isMDXComponent=!0}}]);