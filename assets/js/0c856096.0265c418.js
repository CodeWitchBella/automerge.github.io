"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9198],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),l=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return n?o.createElement(h,a(a({ref:t},u),{},{components:n})):o.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[d]="string"==typeof e?e:r,a[1]=c;for(var l=2;l<i;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8957:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>s});var o=n(7462),r=(n(7294),n(3905));const i={sidebar_position:6},a="Managing Conflicts",c={unversionedId:"cookbook/conflicts",id:"cookbook/conflicts",isDocsHomePage:!1,title:"Managing Conflicts",description:"Automerge allows different nodes to independently make arbitrary changes to their respective copies",source:"@site/docs/cookbook/conflicts.md",sourceDirName:"cookbook",slug:"/cookbook/conflicts",permalink:"/docs/cookbook/conflicts",editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/cookbook/conflicts.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Persistence",permalink:"/docs/cookbook/persistence"},next:{title:"How Automerge works",permalink:"/docs/how-it-works/backend"}},s=[{value:"What is a Conflict?",id:"what-is-a-conflict",children:[],level:2}],l={toc:s},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,o.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"managing-conflicts"},"Managing Conflicts"),(0,r.kt)("p",null,"Automerge allows different nodes to independently make arbitrary changes to their respective copies\nof a document. In most cases, those changes can be combined without any trouble. For example, if\nusers modify two different objects, or two different properties in the same object, then it is\nstraightforward to combine those changes."),(0,r.kt)("h2",{id:"what-is-a-conflict"},"What is a Conflict?"),(0,r.kt)("p",null,"If users concurrently insert or delete items in a list (or characters in a text document), Automerge\npreserves all the insertions and deletions. If two users concurrently insert at the same position,\nAutomerge will ensure that on all nodes the inserted items are placed in the same order."),(0,r.kt)("p",null,"The only case Automerge cannot handle automatically, because there is no well-defined resolution, is\n",(0,r.kt)("strong",{parentName:"p"},"when users concurrently update the same property in the same object"),' (or, similarly, the same\nindex in the same list). In this case, Automerge picks one of the concurrently written\nvalues as the "winner", and it ensures that this winner is the same on all nodes:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Create two different documents\nlet doc1 = Automerge.change(Automerge.init(), doc => {\n  doc.x = 1\n})\nlet doc2 = Automerge.change(Automerge.init(), doc => {\n  doc.x = 2\n})\ndoc1 = Automerge.merge(doc1, doc2)\ndoc2 = Automerge.merge(doc2, doc1)\n// Now, doc1 might be either {x: 1} or {x: 2} -- the choice is random.\n// However, doc2 will be the same, whichever value is chosen as winner.\nassert.deepEqual(doc1, doc2)\n")),(0,r.kt)("p",null,"Although only one of the concurrently written values shows up in the object, the other values are\nnot lost. They are merely relegated to a conflicts object. Suppose ",(0,r.kt)("inlineCode",{parentName:"p"},"doc.x = 2"),' is chosen as the\n"winning" value:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"doc1 // {x: 2}\ndoc2 // {x: 2}\nAutomerge.getConflicts(doc1, 'x') // {'1@01234567': 1, '1@89abcdef': 2}\nAutomerge.getConflicts(doc2, 'x') // {'1@01234567': 1, '1@89abcdef': 2}\n")),(0,r.kt)("p",null,"Here, we've recorded a conflict on property ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),". The object returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"getConflicts"),' contains the\nconflicting values, both the "winner" and the "loser". You might use the information in the\nconflicts object to show the conflict in the user interface. The keys in the conflicts object are\nthe internal IDs of the operations that updated the property ',(0,r.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,r.kt)("p",null,"The next time you assign to a conflicting property, the conflict is automatically considered to be\nresolved, and the conflict disappears from the object returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"Automerge.getConflicts()"),"."),(0,r.kt)("p",null,"Automerge uses a combination of LWW (last writer wins) and multi-value register. By default, if you read from ",(0,r.kt)("inlineCode",{parentName:"p"},"doc.foo")," you will get the LWW semantics, but you can also see the conflicts by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"Automerge.getConflicts(doc, 'foo')")," which has multi-value semantics."),(0,r.kt)("p",null,"Every operation has a unique operation ID that is the combination of a counter and the actorId that generated it. Conflicts are ordered based on the counter first (using the actorId only to break ties when operations have the same counter value)."))}d.isMDXComponent=!0}}]);