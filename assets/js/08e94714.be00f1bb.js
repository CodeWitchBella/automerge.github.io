"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1529],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=s(n),m=l,h=c["".concat(p,".").concat(m)]||c[m]||d[m]||r;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=m;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[c]="string"==typeof e?e:l,i[1]=o;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9973:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return u}});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],o={},p="Storage",s={unversionedId:"how-it-works/storage",id:"how-it-works/storage",isDocsHomePage:!1,title:"Storage",description:"From operations to changes",source:"@site/docs/how-it-works/storage.md",sourceDirName:"how-it-works",slug:"/how-it-works/storage",permalink:"/docs/how-it-works/storage",editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/how-it-works/storage.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Runtime",permalink:"/docs/how-it-works/runtime"},next:{title:"Sync Protocol",permalink:"/docs/how-it-works/sync"}},u=[{value:"From operations to changes",id:"from-operations-to-changes",children:[],level:2},{value:"Change encoding",id:"change-encoding",children:[{value:"Encoding",id:"encoding",children:[],level:3},{value:"Change metadata",id:"change-metadata",children:[],level:3},{value:"Example",id:"example",children:[{value:"Change metadata",id:"change-metadata-1",children:[],level:4},{value:"Operation column metadata",id:"operation-column-metadata",children:[],level:4},{value:"Operation columns",id:"operation-columns",children:[],level:4}],level:3}],level:2},{value:"Document encoding",id:"document-encoding",children:[{value:"Example",id:"example-1",children:[{value:"change columns metadata",id:"change-columns-metadata",children:[],level:4},{value:"operation columns metadata",id:"operation-columns-metadata",children:[],level:4},{value:"change columns",id:"change-columns",children:[],level:4},{value:"operation columns",id:"operation-columns-1",children:[],level:4}],level:3}],level:2},{value:"Reference",id:"reference",children:[],level:2}],c={toc:u},d="wrapper";function m(e){var t=e.components,o=(0,l.Z)(e,i);return(0,r.kt)(d,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"storage"},"Storage"),(0,r.kt)("h2",{id:"from-operations-to-changes"},"From operations to changes"),(0,r.kt)("p",null,"Before applying operations received from other actors, it's necessary to ensure that they are causally ready. This rule applies to most Operation-based CRDTs ",(0,r.kt)("a",{parentName:"p",href:"#refer-anchor-1"},(0,r.kt)("sup",null,"1")),"."),(0,r.kt)("p",null,"We can use vector clocks to ensure that all operations are causally applied, but it is not Byzantine fault tolerant. Another way is to use Hash DAG ",(0,r.kt)("a",{parentName:"p",href:"#refer-anchor-2"},(0,r.kt)("sup",null,"2")),". By recording the dependencies of each operation, other actors can determine if it is causally ready when they receive it by checking if its dependencies exist in the current OpSet."),(0,r.kt)("p",null,"As the number of operations increases, maintaining the Hash DAG can become cumbersome. In Automerge, we take a different approach by using ",(0,r.kt)("inlineCode",{parentName:"p"},"change"),". A ",(0,r.kt)("inlineCode",{parentName:"p"},"change")," is a combination of operations, as you have seen before:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut doc = Automerge::new();\nlet mut tx = doc.transaction();\ntx.put(ROOT, "name", "Alice")?;\ntx.put(ROOT, "age", "21")?;\ntx.commit();\n')),(0,r.kt)("p",null,"In this example, ",(0,r.kt)("inlineCode",{parentName:"p"},'put(root, "name", "Alice")')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'put(root, "age", 21)')," belong to the same transaction. When committing, we combine all operations to create a change. A change is the minimum unit of applying, which implies that all the operations in a change are either fully applied or not applied at all."),(0,r.kt)("p",null,"By doing so, we can manage the dependencies between changes rather than dependencies between operations. In Automerge, we use a ",(0,r.kt)("inlineCode",{parentName:"p"},"struct ChangeGraph")," to maintain this Hash DAG:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub(crate) struct ChangeGraph {\n    nodes: Vec<ChangeNode>,\n    edges: Vec<Edge>,\n    hashes: Vec<ChangeHash>,\n    nodes_by_hash: BTreeMap<ChangeHash, NodeIdx>,\n}\n")),(0,r.kt)("p",null,"For example, a change graph created by actors may look like this:"),(0,r.kt)("img",{src:n(7797).Z,width:"60%"}),(0,r.kt)("p",null,"Before applying change D, it is necessary to ensure that changes B and C have already been applied, as illustrated in the diagram."),(0,r.kt)("p",null,"Moreover, using changes not only avoids the need to maintain a large number of dependencies but also enables us to compress operations efficiently. These operations can be viewed as a table, where each operation represents a row in the table. By utilizing columnar encoding, we can encode this table and greatly reduce the space required to store it."),(0,r.kt)("p",null,"Moving forward, we will explore the process of encoding these operations into a compact format. Before proceeding, you have the option to familiarize yourself with the ",(0,r.kt)("a",{parentName:"p",href:"https://automerge.org/docs/how-it-works/binary-format/"},"specification of Automerge binary encoding"),". However, it is also possible to skip the specification for now, as we will provide essential information on encoding a basic change in the following sections. In case you encounter any difficulties, you can refer back to the specification to resolve them."),(0,r.kt)("h2",{id:"change-encoding"},"Change encoding"),(0,r.kt)("p",null,"In order to exchange changes between actors, we need to encode them. If we serialize all operations directly in sequence, it would take up a lot of space. This is because we use a large amount of metadata to describe elements in Automerge. For example, when working with text, we use UTF-8 to describe a character, but we need to use hundreds of bytes to describe metadata related to it, such as OpId, objId, and so on."),(0,r.kt)("p",null,"Therefore, to compress operations during the encoding of changes, we utilize columnar encoding. To give you an intuitive impression, we provide an example:"),(0,r.kt)("img",{src:n(3096).Z,width:"60%"}),(0,r.kt)("p",null,"When we perform columnar encoding on a table consisting of such operations, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"[5, 0@actor0]")," to encode the ",(0,r.kt)("inlineCode",{parentName:"p"},"obj")," column, which represents 5 occurrences of ",(0,r.kt)("inlineCode",{parentName:"p"},"0@actor0"),"."),(0,r.kt)("p",null,"In the next section, we will describe how to perform columnar encoding on a table of operations specifically."),(0,r.kt)("h3",{id:"encoding"},"Encoding"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Run Length Encoding (RLE)")),(0,r.kt)("p",null,"Run length encoded column consists of multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"(length, value)")," pairs. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"[5, 5, 5, 3, 3]")," can be encoded as ",(0,r.kt)("inlineCode",{parentName:"p"},"[(3, 5), (2, 3)]"),"."),(0,r.kt)("p",null,"To elaborate further, assuming the ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"k"),", we follow these rules:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If k > 0, it means that the value is repeated ",(0,r.kt)("inlineCode",{parentName:"li"},"k")," times."),(0,r.kt)("li",{parentName:"ol"},"If k = 0, it means that ",(0,r.kt)("inlineCode",{parentName:"li"},"null")," is repeated ",(0,r.kt)("inlineCode",{parentName:"li"},"value")," times."),(0,r.kt)("li",{parentName:"ol"},"If k < 0, it means that the next ",(0,r.kt)("inlineCode",{parentName:"li"},"|k|")," values are not repeated. In other words, there is no compression in this case.")),(0,r.kt)("p",null,"In Automerge, we use RLE on the following columns:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Format"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"object counter"),(0,r.kt)("td",{parentName:"tr",align:null},"counter of the object ID each operation targets"),(0,r.kt)("td",{parentName:"tr",align:null},"RLE of uLEB")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key counter"),(0,r.kt)("td",{parentName:"tr",align:null},"counter of the operation ID of the key of each operation"),(0,r.kt)("td",{parentName:"tr",align:null},"RLE of uLEB")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key string"),(0,r.kt)("td",{parentName:"tr",align:null},"The string key each operation targets"),(0,r.kt)("td",{parentName:"tr",align:null},"RLE of UTF8 Strings")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"action"),(0,r.kt)("td",{parentName:"tr",align:null},"The Action of each operation"),(0,r.kt)("td",{parentName:"tr",align:null},"RLE of uLEB")))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"uLEB (unsigned Little-Endian Base) is a variable-length encoding for unsigned integer.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Delta encoding")),(0,r.kt)("p",null,"When dealing with certain columns, RLE alone may not be efficient enough. For instance, if we have a column ",(0,r.kt)("inlineCode",{parentName:"p"},"[1, 2, 3, 5, 7]"),", we cannot use RLE to compress it. One solution is to use delta encoding first, encoding it as ",(0,r.kt)("inlineCode",{parentName:"p"},"[+1, +1, +1, +2, +2]"),", and then use RLE to encode it as ",(0,r.kt)("inlineCode",{parentName:"p"},"[(3, +1), (2, +2)]"),"."),(0,r.kt)("p",null,"In Automerge, we use delta encoding on the following columns:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Format"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"counter"),(0,r.kt)("td",{parentName:"tr",align:null},"The counter of each operations ID"),(0,r.kt)("td",{parentName:"tr",align:null},"Delta encoding of uLEB")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Boolean encoding")),(0,r.kt)("p",null,"For the boolean type, we can make it more compact. The column contains sequences of uLEB integers that represent the lengths of alternating sequences of false/true. The initial value of the column is always false. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"[false, true, true, true, false, false]")," would be encoded as ",(0,r.kt)("inlineCode",{parentName:"p"},"[1, 3, 2]"),"."),(0,r.kt)("p",null,"In Automerge, we use boolean encoding on the following columns:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"insert"),(0,r.kt)("td",{parentName:"tr",align:null},"Whether or not this is an insert operation")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Actor encoding")),(0,r.kt)("p",null,"Automerge utilizes a 16-byte random number to denote an actor ID. Due to its high byte count and small cardinality, it can be more efficiently managed by first saving it in a ",(0,r.kt)("inlineCode",{parentName:"p"},"index -> actor ID")," map and then storing only the index. To store the index, RLE of uLEB is used."),(0,r.kt)("p",null,"In Automerge, we use actor encoding on the following columns:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"object actor ID"),(0,r.kt)("td",{parentName:"tr",align:null},"actor index of object ID each operation targets")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"key actor ID"),(0,r.kt)("td",{parentName:"tr",align:null},"actor of the operation ID of the key of each operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"actor ID"),(0,r.kt)("td",{parentName:"tr",align:null},"The actor of each operations ID")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Group encoding")),(0,r.kt)("p",null,"In Automerge, some columns can contain multiple values per operation. To handle this, group encoding is used. It consists of two columns:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The first column represents the number of elements in the row and is encoded using RLE of uLEB. For instance, ",(0,r.kt)("inlineCode",{parentName:"p"},"[[1, 2], [1, 2, 3]]")," would be encoded as ",(0,r.kt)("inlineCode",{parentName:"p"},"[2, 3]"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The second column contains the actual stored values and is encoded as a flat list. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"[[1, 2], [1, 2, 3]]")," would be encoded as ",(0,r.kt)("inlineCode",{parentName:"p"},"[1, 2, 1, 2, 3]"),". Additionally, group encoding can be combined with other encodings such as delta encoding, which would encode ",(0,r.kt)("inlineCode",{parentName:"p"},"[1, 2, 1, 2, 3]")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"[+1, +1, -1, +1, +1]"),"."))),(0,r.kt)("p",null,"In Automerge, we use group encoding on the following columns:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Format"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"predecessor actor IDs"),(0,r.kt)("td",{parentName:"tr",align:null},"The actor ID of each predecessor\u2019s operation ID"),(0,r.kt)("td",{parentName:"tr",align:null},"Grouped Actor encoding")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"predecessor counters"),(0,r.kt)("td",{parentName:"tr",align:null},"The counter of each predecessor\u2019s operation ID"),(0,r.kt)("td",{parentName:"tr",align:null},"Grouped Delta encoding")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"successor actor IDs"),(0,r.kt)("td",{parentName:"tr",align:null},"The actor ID of each successor\u2019s operation ID"),(0,r.kt)("td",{parentName:"tr",align:null},"Grouped Actor encoding")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"successor counters"),(0,r.kt)("td",{parentName:"tr",align:null},"The counter of each successor\u2019s operation ID"),(0,r.kt)("td",{parentName:"tr",align:null},"Grouped Delta encoding")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Value encoding")),(0,r.kt)("p",null,"For primitive values, we need to indicate their type and length. Therefore, we divide the value encoding into two columns:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The first column stores the value metadata, which looks like this\uff1a")),(0,r.kt)("img",{src:n(3995).Z,width:"80%"}),(0,r.kt)("p",null,"The types represented by numbers ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"9")," currently include: null, false, true, unsigned integer, signed integer, IEEE754 float, UTF8 string, bytes, counter, and timestamp."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"The second column stores the actual bytes.")),(0,r.kt)("p",null,"In Automerge, we use value encoding on the following columns:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"value"),(0,r.kt)("td",{parentName:"tr",align:null},"The value of this operation")))),(0,r.kt)("h3",{id:"change-metadata"},"Change metadata"),(0,r.kt)("p",null,"In addition to including all the operations, a ",(0,r.kt)("inlineCode",{parentName:"p"},"change")," also needs to include some of its own metadata. In memory, we represent a ",(0,r.kt)("inlineCode",{parentName:"p"},"change")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub(crate) struct Change<'a, O: OpReadState> {\n    /// The raw bytes of the entire chunk containing this change, including the header.\n    bytes: Cow<'a, [u8]>,\n    header: Header,\n    dependencies: Vec<ChangeHash>,\n    actor: ActorId,\n    other_actors: Vec<ActorId>,\n    seq: u64,\n    start_op: NonZeroU64,\n    timestamp: i64,\n    message: Option<String>,\n    ops_meta: ChangeOpsColumns,\n    /// The range in `Self::bytes` where the ops column data is\n    ops_data: Range<usize>,\n    extra_bytes: Range<usize>,\n    _phantom: PhantomData<O>,\n}\n")),(0,r.kt)("p",null,"Here's a brief explanation of what these metadata mean:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"header")," contains information about the change chunk, such as the chunk type and checksum."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"dependencies")," are the hash values of the changes on which this change depends."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"actor")," refers to the actor ID that constructed the current change."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"other_actors")," includes all the actors that appear later. It is actually the ",(0,r.kt)("inlineCode",{parentName:"li"},"index -> ActorID")," map."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"seq")," refers to the number assigned to the current change within the actor. Note that it is not the Lamport clock. ",(0,r.kt)("inlineCode",{parentName:"li"},"<actor ID, seq>")," uniquely identifies a change."),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"start_op")," refers to the operation ID at the beginning of the current change."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"timestamp")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"message")," are specified during ",(0,r.kt)("inlineCode",{parentName:"li"},"commit"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"ops_meta")," describes the metadata of the operation table, such as which columns are included."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"ops_data")," includes the actual data of the operation table.")),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("p",null,"We use an example to illustrate how a change is encoded. Suppose we have the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut doc = Automerge::new();\nlet mut tx = doc.transaction();\ntx.put(ROOT, "name", "Alice")?;\ntx.put(ROOT, "age", 21)?;\ntx.commit();\n')),(0,r.kt)("p",null,"It will be encoded to the byte sequence like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"856f4a83264ba5060140001003ebab6d29df47f39c5ea7d4cd9d6e03010100000006150a340142025604570970027e046e616d65036167650202017e8601144c69616e6772756e150200\n856f4a83fc117446013c0010ba92a37960334606aa47606579716f20010100000006150a340142025603570670027e046e616d65036167650202017e5614416c696365150200\n")),(0,r.kt)("p",null,"We can deconstruct it into different parts:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"0x856f4a83 // magic\n0xfc117446 // checksum\n0x01 // chuck type\n0x3c // chunk length\n0x00 // dependencies\n0x10 // actor length\n0xba92a37960334606aa47606579716f20 //actor \n0x01 // sequence number\n0x01 // start op\n0x00 // time\n0x00 // message length\n0x00 // other actors\n0x06150a34014202560357067002 // operation column metadata\n0x7e046e616d65036167650202017e5614416c696365150200 // operation columns\n")),(0,r.kt)("h4",{id:"change-metadata-1"},"Change metadata"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"magic")),(0,r.kt)("p",null,"The magic is defined as ",(0,r.kt)("inlineCode",{parentName:"p"},"[0x85, 0x6f, 0x4a, 0x83]"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"checksum")),(0,r.kt)("p",null,"The checksum is calculated by computing the SHA256 of all subsequent parts and taking the first 4 bytes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"SHA256(013c0010ba92a37960334606aa47606579716f20010100000006150a340142025603570670027e046e616d65036167650202017e5614416c696365150200) = fc117446c2701317ab462d610d17981fc12ac4cae6e242515d401db831a6e6d4\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"chunk type")),(0,r.kt)("p",null,"The chunk type of a change is always equal to 0x01."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"chunk length")),(0,r.kt)("p",null,"The chunk length indicates how many bytes follow and is of type uLEB. In this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"0x3c")," is equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"0b00111100"),", so the length of the following bytes is ",(0,r.kt)("inlineCode",{parentName:"p"},"0b011 1100"),", which is 60 bytes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"dependencies")),(0,r.kt)("p",null,"The format for dependencies is as follows: first, there is a uLEB that indicates how many dependencies there are. In this case, the value is 0, which means there are no dependencies"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"actor length")),(0,r.kt)("p",null,"This is in uLEB format, which indicates the length of the actor in bytes. ",(0,r.kt)("inlineCode",{parentName:"p"},"0x10")," represents 16 bytes, so the next 16 bytes represent the actor."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"actor")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0xba92a37960334606aa47606579716f20")," is the actor ID."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"sequence number")),(0,r.kt)("p",null,"In uLEB format, it represents the seq of the change. Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"0x01")," = 1, so the sequence number is 1."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"start op")),(0,r.kt)("p",null,"In uLEB format, ",(0,r.kt)("inlineCode",{parentName:"p"},"0x01")," = 1, so the start op is 1."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"time")),(0,r.kt)("p",null,"In uLEB format, the time is empty by default, so here ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00")," = 0."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"message length")),(0,r.kt)("p",null,"In uLEB format, the message is empty by default, so here ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00")," = 0."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"other actors")),(0,r.kt)("p",null,"It uses a uLEB to indicate how many actors there are. Here, since we have no other actors, ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00")," = 0."),(0,r.kt)("h4",{id:"operation-column-metadata"},"Operation column metadata"),(0,r.kt)("p",null,"Following the uLEB ",(0,r.kt)("inlineCode",{parentName:"p"},"0x06")," = 6 indicating the number of columns, there are 6 pairs of <Column Specification, Column Length>:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Specification"),(0,r.kt)("th",{parentName:"tr",align:null},"Column Length"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x15 = 21, key string"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0a")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x34 = 52, insert"),(0,r.kt)("td",{parentName:"tr",align:null},"0x01")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x42 = 66, action"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x56 = 86, value metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"0x03")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x57 = 87, value"),(0,r.kt)("td",{parentName:"tr",align:null},"0x06")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x70 = 112, predecessor group"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")))),(0,r.kt)("p",null,"The sum of ",(0,r.kt)("inlineCode",{parentName:"p"},"0x0a + 0x01 + 0x02 + 0x03 + 0x06 + 0x02")," is 24, so the next 24 bytes are operation columns."),(0,r.kt)("h4",{id:"operation-columns"},"Operation columns"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"key string\uff1a")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"7e046e616d650361676\n")),(0,r.kt)("p",null,"In Automerge, ",(0,r.kt)("inlineCode",{parentName:"p"},"key string")," is encoded using Run Length Encoding (RLE)."),(0,r.kt)("p",null,"Here, the length is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x7e = 0b01111110"),", which in two's complement is ",(0,r.kt)("inlineCode",{parentName:"p"},"-2"),", indicating that there is no compression."),(0,r.kt)("p",null,"The value part is ",(0,r.kt)("inlineCode",{parentName:"p"},"046e616d6503616765"),", which consists of several ",(0,r.kt)("inlineCode",{parentName:"p"},"<uLEB byte count + actual bytes>")," pairs."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The first byte count is ",(0,r.kt)("inlineCode",{parentName:"li"},"0x04 = 4"),", indicating that the next 4 bytes is the first string, which is ",(0,r.kt)("inlineCode",{parentName:"li"},"0x6e616d65"),', resulting in "name" when decoded using UTF-8.'),(0,r.kt)("li",{parentName:"ol"},"The second byte count is ",(0,r.kt)("inlineCode",{parentName:"li"},"0x03 = 3"),", indicating that the next 3 bytes is the second string, which is ",(0,r.kt)("inlineCode",{parentName:"li"},"0x616765"),', resulting in "age" when decoded using UTF-8.')),(0,r.kt)("p",null,"Therefore, we end up with the key strings ",(0,r.kt)("inlineCode",{parentName:"p"},'["name", "age"]'),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"insert")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"02\n")),(0,r.kt)("p",null,"The type of ",(0,r.kt)("inlineCode",{parentName:"p"},"insert")," is boolean, which is encoded using ",(0,r.kt)("inlineCode",{parentName:"p"},"Boolean Encoding"),"."),(0,r.kt)("p",null,"Therefore, ",(0,r.kt)("inlineCode",{parentName:"p"},"[0x02]")," represents ",(0,r.kt)("inlineCode",{parentName:"p"},"[false, false]"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"action")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0201\n")),(0,r.kt)("p",null,"RLE is used for the action column. Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"0x02")," = 2, indicating that the value is repeated twice."),(0,r.kt)("p",null,"The value part is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x01"),". Repeating it twice gives us ",(0,r.kt)("inlineCode",{parentName:"p"},"[0x01, 0x01]"),"."),(0,r.kt)("p",null,"According to the Automerge specification, ",(0,r.kt)("inlineCode",{parentName:"p"},"0x01"),' as the action value means "set". Therefore, the action column is ',(0,r.kt)("inlineCode",{parentName:"p"},"[set, set]"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"value metadata")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"7e5614\n")),(0,r.kt)("p",null,"The value metadata is encoded using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Value Encoding"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0x56 = 0101 0110")," can be interpreted as ",(0,r.kt)("inlineCode",{parentName:"p"},"0b 101 0110"),", which means the first type is ",(0,r.kt)("inlineCode",{parentName:"p"},"0b0110")," (String), and the length is ",(0,r.kt)("inlineCode",{parentName:"p"},"0b101 = 5 bytes"),"."),(0,r.kt)("p",null,"The following ",(0,r.kt)("inlineCode",{parentName:"p"},"0x14 = 0b0001 0100"),",  indicates that the second type is ",(0,r.kt)("inlineCode",{parentName:"p"},"0b100")," (Signed Integer), and the length is ",(0,r.kt)("inlineCode",{parentName:"p"},"0b1 = 1 byte"),"."),(0,r.kt)("p",null,"So the entire value metadata column can be interpreted as ",(0,r.kt)("inlineCode",{parentName:"p"},"[<String, 8>, <Signed Integer, 1>]"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"value")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"416c69636515\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0x416c696365"),' is converted to the UTF-8 string "Alice". And ',(0,r.kt)("inlineCode",{parentName:"p"},"0x15 = 21"),"."),(0,r.kt)("p",null,"Therefore, the value column can be interpreted as ",(0,r.kt)("inlineCode",{parentName:"p"},'["Alice", 21]'),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"predecessor group")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0200\n")),(0,r.kt)("p",null,"The first column of the predecessor group is encoded using RLE, which is equivalent to ","[0x00, 0x00]"," here. This means that there are no predecessors for these two operations. Therefore, the predecessor group is interpreted as ",(0,r.kt)("inlineCode",{parentName:"p"},"[[], []]"),"."),(0,r.kt)("h2",{id:"document-encoding"},"Document encoding"),(0,r.kt)("p",null,"A new actor may start joining the synchronization of a document without any changes. It is inefficient to transmit each change individually. In this scenario, we can serialize and transmit the entire document. Furthermore, serialization of the document is also useful when we intend to persist it in disk storage."),(0,r.kt)("p",null,"The document is essentially a set of changes. However, when we encode it, we divide it into two distinct tables: the change table and the operation table. The change table stores the metadata related to the changes, whereas the operation table stores all the operations of the document."),(0,r.kt)("p",null,"The reason why we separate the change table and the operation table is that doing so allows us to better utilize columnar encoding, which results in higher compression rates."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub(crate) struct Document<'a> {\n    bytes: Cow<'a, [u8]>,\n    #[allow(dead_code)]\n    compressed_bytes: Option<Cow<'a, [u8]>>,\n    header: Header,\n    actors: Vec<ActorId>,\n    heads: Vec<ChangeHash>,\n    op_metadata: DocOpColumns,\n    op_bytes: Range<usize>,\n    change_metadata: DocChangeColumns,\n    change_bytes: Range<usize>,\n    #[allow(dead_code)]\n    head_indices: Vec<u64>,\n}\n")),(0,r.kt)("h3",{id:"example-1"},"Example"),(0,r.kt)("p",null,"We use an example to illustrate how a document is encoded. Suppose we have the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut doc = Automerge::new();\nlet mut tx1 = doc.transaction();\ntx1.put(ROOT, "name", "Bob")?;\ntx1.put(ROOT, "age", 21)?;\ntx1.commit();\n\nlet mut tx2 = doc.transaction();\ntx2.put(ROOT, "gender", "male")?;\ntx2.commit();\ndoc.save();\n')),(0,r.kt)("p",null,"It will be encoded to the byte sequence like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"856f4a83e7a6f50e009301011013336ec1ed354befa60b3e3f05346028012f2f0a65b40461263a496749d8bb0b0746c234cbddb092e11473861242638a0c07010203021303230240034302560208151121022304340142025605570d800102020002017e020102007e00017f0002077d036167650667656e646572046e616d6503007d02017e0303017d14468601156d616c654c69616e6772756e030001\n856f4a834afcae9c008d01011015cb7623f0314fc09773daafcf4138d7016cdffc539c7e02a93ab4f9762fc4466b90fc4134c6662382d067f02d9e9418bf070102030213032302400343025602081511210223043401420256045708800102020002017e020102007e00017f0002077d036167650667656e646572046e616d6503007d02017e0303017d144636156d616c65426f62030001\n")),(0,r.kt)("p",null,"We can deconstruct it into different parts:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"0x856f4a83 // magic\n0x4afcae9c // checksum\n0x00 // chunk type\n0x8d01 // chunk length\n0x011015cb7623f0314fc09773daafcf4138d7 // actors\n0x016cdffc539c7e02a93ab4f9762fc4466b90fc4134c6662382d067f02d9e9418bf // heads\n0x070102030213032302400343025602 // change column metadata\n0x081511210223043401420256045708800102 // operation column metadata\n0x020002017e020102007e00017f000207 // change column\n0x7d036167650667656e646572046e616d6503007d02017e0303017d144636156d616c65426f620300 // operation columns\n0x01 // heads index\n")),(0,r.kt)("p",null,"As most of the fields are similar to change encoding, we will not explain them here. Instead, we will only illustrate the ",(0,r.kt)("inlineCode",{parentName:"p"},"change column metadata")," , ",(0,r.kt)("inlineCode",{parentName:"p"},"operation column metadata"),",  ",(0,r.kt)("inlineCode",{parentName:"p"},"change column")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"operation column")," ."),(0,r.kt)("h4",{id:"change-columns-metadata"},"change columns metadata"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0x070102030213032302400343025602\n")),(0,r.kt)("p",null,"Following the uLEB ",(0,r.kt)("inlineCode",{parentName:"p"},"0x07")," = 7 indicating the number of columns, there are 7 pairs of <Column Specification, Column Length>:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Specification"),(0,r.kt)("th",{parentName:"tr",align:null},"Column Length"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x01 = 1, actor"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x03 = 3, sequence number"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x13 = 19, maxop"),(0,r.kt)("td",{parentName:"tr",align:null},"0x03")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x23 = 35, time"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x40 = 64, dependencies group"),(0,r.kt)("td",{parentName:"tr",align:null},"0x03")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x43 = 67, dependencies index"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x56 = 86, extra metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")))),(0,r.kt)("p",null,"0x02 + 0x02 + 0x03 + 0x02 + 0x03 + 0x02 + 0x02 = 16 bytes."),(0,r.kt)("h4",{id:"operation-columns-metadata"},"operation columns metadata"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0x081511210223043401420256045708800102\n")),(0,r.kt)("p",null,"Following the uLEB ",(0,r.kt)("inlineCode",{parentName:"p"},"0x08")," = 8 indicating the number of columns, there are 8 pairs of <Column Specification, Column Length>:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Column Specification"),(0,r.kt)("th",{parentName:"tr",align:null},"Column Length"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x15 = 21, key string"),(0,r.kt)("td",{parentName:"tr",align:null},"0x11")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x21 = 33, actor ID"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x23 = 35, counter"),(0,r.kt)("td",{parentName:"tr",align:null},"0x04")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x34 = 52, insert"),(0,r.kt)("td",{parentName:"tr",align:null},"0x01")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x42 = 66, action"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x56 = 86, value metadata"),(0,r.kt)("td",{parentName:"tr",align:null},"0x04")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x57 = 87, value"),(0,r.kt)("td",{parentName:"tr",align:null},"0x08")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0x8001 = 128, successor group"),(0,r.kt)("td",{parentName:"tr",align:null},"0x02")))),(0,r.kt)("p",null,"0x11 + 0x02 + 0x04 + 0x01 + 0x02 + 0x04 + 0x08 + 0x02 = 40 bytes"),(0,r.kt)("h4",{id:"change-columns"},"change columns"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0x020002017e020102007e00017f000207\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"actor")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0200\n")),(0,r.kt)("p",null,"The actor column uses RLE. First, the length is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x02"),", indicating that the value is repeated twice. Then, the value is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00"),", indicating that the actor column is ","[0x00, 0x00]","."),(0,r.kt)("p",null,"In this case, 0x00 refers to the first actor in the actors list, which is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x011015cb7623f0314fc09773daafcf4138d7"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"sequence number")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0201\n")),(0,r.kt)("p",null,"The sequence number uses RLE. Here, the length is 0x02, indicating that the value is repeated twice. The value is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x01"),", which means that the actual value is ","[0x01, 0x01]","."),(0,r.kt)("p",null,"The value part of the sequence number uses delta encoding. Therefore, ","[0x01, 0x01]"," is equivalent to ","[1, 2]","."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"maxop")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"7e0201\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"maxop"),"  uses RLE. Here, the length is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x7e"),", which is equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"-2")," in 2's comlement number format. The value is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x0201"),", which mean the actual value is ","[0x02, 0x01]","."),(0,r.kt)("p",null,"Since it is delta encoded, this value represents ","[0x02, 0x03]","."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"time")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0200\n")),(0,r.kt)("p",null,"The length of the RLE is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x02"),", indicating that ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00")," is repeated twice. Therefore, time is not recorded here."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"dependencies group")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"7e0001\n")),(0,r.kt)("p",null,"Dependencies group can be interpreted as ","[0x00, 0x01]",". As a result, the first change has no dependencies, while the second change has one dependency."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"dependencies index")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"7f00\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0x7f")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"-1")," in RLE encoding, indicating that the value is not repeated. The following value is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00"),". The dependencies index for the two changes is therefore: [[], ","[0x00]","]."),(0,r.kt)("h4",{id:"operation-columns-1"},"operation columns"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0x7d036167650667656e646572046e616d6503007d02017e0303017d144636156d616c65426f620300\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"key string")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"7d036167650667656e646572046e616d65\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0x7d"),"  is ",(0,r.kt)("inlineCode",{parentName:"p"},"-3")," in 2's complement, indicating that the value is not repeated. The value part is as follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"03 represents the length of the first value, so the next three bytes are ",(0,r.kt)("inlineCode",{parentName:"li"},"0x616765"),', which corresponds to "age".'),(0,r.kt)("li",{parentName:"ol"},"06 represents the length of the second value, so the next six bytes are ",(0,r.kt)("inlineCode",{parentName:"li"},"0x67656e646572"),', which corresponds to "gender".'),(0,r.kt)("li",{parentName:"ol"},"04 represents the length of the third value, so the next four bytes are ",(0,r.kt)("inlineCode",{parentName:"li"},"0xe616d65"),', which corresponds to "name".')),(0,r.kt)("p",null,"Therefore, the final result is ",'["age", "gender", "name"]',"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"actor ID")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0300\n")),(0,r.kt)("p",null,"Here is RLE encoded, so ",(0,r.kt)("inlineCode",{parentName:"p"},"0x03")," represents repeating 3 times, and the value is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00"),". Therefore, the final decoding result is ","[0x00, 0x00, 0x00]","."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"counter")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"7d02017e\n")),(0,r.kt)("p",null,"The value ",(0,r.kt)("inlineCode",{parentName:"p"},"0x7d")," indicates that there is no repetition, and the sequence of values ",(0,r.kt)("inlineCode",{parentName:"p"},"0x02 0x01 0x7e")," represents the delta encoding ","[+2, +1, -2]",". The resulting decoded sequence is ","[2, 3, 1]","."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"insert")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"03\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0x03")," represents 3 times ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", which is ","[false, false, false]","."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"action")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0301\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0301")," represents three times ",(0,r.kt)("inlineCode",{parentName:"p"},"0x01"),", which means ","[0x01, 0x01, 0x01]","."),(0,r.kt)("p",null,"According to the Automerge specification, ",(0,r.kt)("inlineCode",{parentName:"p"},"0x01"),' as the action value means "set". Therefore, the action column is ',(0,r.kt)("inlineCode",{parentName:"p"},"[set, set, set]"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"value metadata")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"7d144636\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0x7d")," = -3, which means there is no compression used."),(0,r.kt)("p",null,"Next is the value part, which consists of several 64-bit uLEBs:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"14")," = 0001 0100, which means type = 0b100 (Signed integer), length = 0b1 = 1 byte."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"46")," = 0100 0110, which means type = 0b110 (String), length = 0b100 = 4 bytes."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"36")," = 0011 0110, which means type = 0b110 (String), length = 0b11 = 3 bytes.")),(0,r.kt)("p",null,"Therefore, the entire value metadata column can be interpreted as ","[<Signed Integer, 1>, <String, 4>, <String, 3>]","."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"value")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"156d616c65426f62\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Signed Integer, ",(0,r.kt)("inlineCode",{parentName:"li"},"0x15")," = 21"),(0,r.kt)("li",{parentName:"ol"},"String, ",(0,r.kt)("inlineCode",{parentName:"li"},"0x6d616c65"),' = "male"'),(0,r.kt)("li",{parentName:"ol"},"String, ",(0,r.kt)("inlineCode",{parentName:"li"},"0x426f62"),' = "Bob"')),(0,r.kt)("p",null,"Therefore, the entire value column can be interpreted as ",'[21, "male", "Bob"]',"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"successor group")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0300\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0x0300")," means three times ",(0,r.kt)("inlineCode",{parentName:"p"},"0x00"),", which is equivalent to ","[0x00, 0x00, 0x00]","."),(0,r.kt)("p",null,"So there is no successor for all the operations. Hence the operation group can be interpreted as ",(0,r.kt)("inlineCode",{parentName:"p"},"[[], [], []]"),"."),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("div",{id:"refer-anchor-1"}),(0,r.kt)("p",null,"[1]",". M. Shapiro, N. Pregui\xe7a, C. Baquero, and M. Zawirski, \u201cConflict-free replicated data types,\u201d ",(0,r.kt)("em",{parentName:"p"},"Lecture Notes in Computer Science"),", pp. 386\u2013400, 2011. doi:10.1007/978-3-642-24550-3_29 "),(0,r.kt)("div",{id:"refer-anchor-2"}),(0,r.kt)("p",null,"[2]",". Kleppmann M, Howard H. Byzantine eventual consistency and the fundamental limits of peer-to-peer databases","[J]",". arXiv preprint arXiv:2012.00472, 2020."))}m.isMDXComponent=!0},7797:function(e,t,n){t.Z=n.p+"assets/images/storage1-717093ac2d2d97fac7ab69a984bb2800.png"},3096:function(e,t,n){t.Z=n.p+"assets/images/storage2-7aeb194ba145282f4f33c26bdbb37470.png"},3995:function(e,t,n){t.Z=n.p+"assets/images/storage3-6470ef194a5b7c28ec63029d3fcb57d8.png"}}]);